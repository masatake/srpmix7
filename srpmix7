#!/bin/zsh
#
# srpmix7 - the 7th implementation of srpmix
#
# Copyright (C) 2015 Red Hat, Inc.
# Copyright (C) 2015 Masatake YAMATO
#
# Author: Masatake YAMATO <yamato@redhat.com>
#
# program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
readonly prefix=srpmix7
readonly PREFIX=${(U)prefix}
readonly SELF_FULL=$(/usr/bin/realpath $0)
readonly SELF=$0:t
readonly c_version=7.0.0
readonly UCTAGS=${UCTAGS:-~/bin/u-ctags}

#
# TODO
#    subcommands: diag, deploy(kicked from systemd unit), repair,
#                 attach(generate bundle), spider(?), gc-raw, gc-upper, delete
#
#
#
# Namespace
#
# b_: bundle
# c_: constant value in files in "raw directory"
# d_: deploy related
# i_: internal subcommand
# l_: link related
# p_: file/directory names of lower directory structure
# P_: file/directory names of upper directory structure
# s_: status ofexpansion
# x_: expander
#


#
# Lower directory structure
#
readonly -x p_archives=archives
readonly -x p_pre_build=pre-build
readonly -x p_info=info
readonly -x p_status=_status
readonly -x p_bundles=_bundles
readonly -x p_uname=_uname
readonly -x p_uname_version=$p_uname/version
readonly -x p_log=_log
readonly -x p_stmp=__src_tmp
readonly -x p_xtmp=__expander_tmp
readonly -x p_bundle_status=_status
readonly -x p_bundle_log=_log
readonly -x p_bundle_uname=_uname

readonly -x p_srpm_spec=srpm.spec

readonly -x s_unknown=unknown
readonly -x s_successful=successful
readonly -x s_bug=BUG
readonly -x s_incomplete=incomplete

readonly -x s_bundle_unknown=unknown
readonly -x s_bundle_successful=successful

readonly -x p_unknown=${(U)${s_unknown}}
readonly -x p_successful=${(U)${s_successful}}
readonly -x p_bug=${(U)${s_bug}}
readonly -x p_incomplete=${(U)${s_incomplete}}

#
# Upper directory structure
#
readonly -x P_sources=sources
readonly -x P_cradles=cradles
readonly -x P_cradle_sources=sources
readonly -x P_cradle_conf=_.cradle
readonly -x P_cradle_log=_log
readonly -x P_cradle_bundles=_bundles
readonly -x P_dists=dists

#
# Rearrange zsh behavior
#
enable -r repeat
setopt EXTENDED_GLOB
autoload -Uz catch
autoload -Uz throw

#
# Rearrange the environment
#
export LANG=C
export LC_ALL=C

#
# Initialize registries
#
typeset -A EVAR
EVAR=(
)

typeset -A EVAR_DEFAULT
EVAR_DEFAULT=(
)

typeset -a ICMD
ICMD=(
)

typeset -A ICMD_DESC
ICMD_DESC=(
)

EVAR[TMPDIR]="Directory where temorary directories are created"

EVAR[UCTAGS]="Path for Universal ctags"
EVAR_DEFAULT[UCTAGS]=${UCTAGS}

typeset -A REQUIREMENTS
REQUIREMENTS=(
)

typeset -A BUNDLES
BUNDLES=(
)

typeset -A LTYPES
LTYPES=(
)

typeset -A USE_HOOK
USE_HOOK=(
)

#
#
# Utilities
#
#
indent()
{
    local i
    local depth=${1:-1}
    while IFS= read -r; do
	repeat $depth ; do
	    printf "	"
	done
	printf "%s\n" "$REPLY"
    done
}

member()
{
    local elt=$1
    local x
    shift

    for x in "$@"; do
	if [ "$x" = "$elt" ]; then
	    return 0
	fi
    done
    return 1
}

is_available()
{
    -S- whence $1
    return $?
}

require()
{
    local c=$1
    local f=$2

    if [[ -n "$f" ]]; then
	is_available $c || -E- "$f requires $c"
    else
	is_available $c || -E- "$c is not found"
    fi
}

check_requirements()
{
    local class=$1
    local name=$2
    local c

    for c in ${=${REQUIREMENTS[${class}_${name}]}}; do
	require $c $class/$name
    done
}

backtrace()
{
    echo "STACK TRACE"
    echo "-----------"
    echo ${(F)funcstack[2,-1]}
}

is_empty_dir()
{
    local d=$1
    local -a a

    a=( $d/*(N) )
    [[ $#a == 0 ]]
    return $?
}

make_all_readable()
{
    local target=$1

    find $target -type f -exec chmod a+r '{}' '+'
    find $target -type d -exec chmod a+rx '{}' '+'
}

make_file_unwritable()
{
    local target=$1

    find $target -type f -exec chmod a-w '{}' '+'
}

# error
-E-()
{

    echo "[ERROR]" "$@"
    backtrace | indent
    exit 1
} 1>&2

-E%-()
{
    local fmt=$1
    shift

    printf "[ERROR] ${fmt}\n" "$@"
    backtrace | indent
    exit 1
} 1>&2

# throw
-T-()
{
    local o=$1
    shift

    echo "[ERROR]" "$@"
    backtrace | indent
    throw $o
} 1>&2

-T%-()
{
    local o=$1
    shift
    local fmt=$1
    shift

    printf "[ERROR] ${fmt}\n" "$@"
    backtrace | indent
    throw $o
} 1>&2

-W-()
{
    echo "[WARNING]" "$@"  1>&2
}

-W%-()
{
    local fmt=$1
    shift

    printf "[WARNING] ${fmt}\n" "$@"  1>&2
}

# silent
-S-()
{
    "$@" > /dev/null 2>&1
    return $?
}

name_prefix()
{
    echo -n ${1[1]}
}

use_hook_p()
{
    local k=$1
    if [[ -z "${USE_HOOK[$k]}" ]]; then
	return 1
    else
	return 0
    fi
}

run_hook()
{
    local hookdir=$1
    local type=$2
    local hook=$3
    shift 3

    local cmd="${hookdir}/${type}/${hook}"
    if [[ -x "$cmd" ]]; then
	"$cmd" "$@"
    fi
}

list_hooks()
{
    local t=$1
    local i=$2
    local h
    for h in ${USE_HOOK[$t]}; do
	echo "$i$h"
    done
}

print_available_hooks()
{
    local t=$1

    echo "Available hooks in $t:"
    list_hooks "$t" "	"
}


#
#
# Subcommand related operations
#
#
subcommand_enumerate()
{
    local t

    for t in icmd xcmd; do
	${t}_enumerate "$@"
    done | sort
}

subcommand_exist_p()
{
    local c=$1
    local t

    for t in icmd xcmd; do
	if ${t}_exist_p $c; then
	    return 0
	fi
    done

    return 1
}

subcommand_help()
{
    local c=$1
    local t

    for t in icmd xcmd; do
	if ${t}_exist_p $c; then
	    ${t}_help $c
	    return $?
	fi
    done

    return 1
}

subcommand_run()
{
    local c=$1
    shift
    local t


    for t in icmd xcmd; do
	if ${t}_exist_p $c; then
	    ${t}_run $c "$@"
	    return $?
	fi
    done

    return 1
}

#
#
# XCMD related operations
#
#
EVAR[XCMD_DIR]="Directory where external subcommand files are"
EVAR_DEFAULT[XCMD_DIR]="/usr/libexec/${prefix}/xcmd"

xcmd_exist_p()
{
    local c=$1
    test -x ${XCMD_DIR}/$c
}

xcmd_enumerate()
{
    local v=$1
    local x

    for x in ${XCMD_DIR}/xcmd-*(.xN); do
	if [ "$v" = "-v" ]; then
	    =printf "%-20s %s\n" "${${x:t}/xcmd-/}" "$(${x} desc)"

	else
	    echo  $c
	fi
    done

}

xcmd_help()
{
    local c=$1

    if xcmd_exist_p "${c}"; then
	${XCMD_DIR}/$c help
    else
	-E- "No such external subcommand: ${c}"
	return 1
    fi
}

xcmd_run()
{
    local c=$1
    shift 1
    ${XCMD_DIR}/$c run "$@"
}

#
#
# ICMD related operations
#
#
icmd_exist_p()
{
    local c=$1
    local s

    for s in run help; do
	if ! is_available i_${c}_${s}; then
	    return 1
	fi
    done

    return 0
}

icmd_enumerate()
{
    local v=$1
    local c
    for c in ${ICMD[@]}; do
	if [ "$v" = "-v" ]; then
	    =printf "%-20s %s\n" "${c}" ${ICMD_DESC[$c]}
	else
	    echo $c
	fi
    done

}

icmd_help()
{
    local c=$1

    i_${c}_help
}

icmd_run()
{
    local c=$1
    shift 1
    i_${c}_run "$@"
}

#
#
# Environment variable related operations
#
#
evar_enumerate()
{
    local v=$1

    local k
    local n
    for k in  ${(k)EVAR}; do
	n="${PREFIX}_$k"
	if [ "$v" = "-v" ]; then
	    =printf "%-10s	<%s>\n" "${n}" ${(P)n}
	else
	    echo "${n}"
	fi
    done
}

#
#
# Subcommand: inull
#
#
ICMD+=null
ICMD_DESC[null]="do nothing (internal command example)"

i_null_help()
{
    echo i_null_help
}

i_null_run()
{
    echo i_null_run
}

#
#
# Subcommand: link
#
#
ICMD+=link
ICMD_DESC[link]="make links"

i_link_help()
{
    local k

    echo "$SELF link [OPTIONS] LTYPE LNAME SOURCES7UPPDERDIR PACKAGE/VERSION--EXPANDER..."
    echo "<not implemented yet> $SELF link [OPTIONS] LTYPE LNAME SOURCES7UPPDERDIR --stdin"
    echo "<not implemented yet> $SELF link [OPTIONS] LTYPE LNAME SOURCES7UPPDERDIR --iso"
    echo "<not implemented yet> $SELF link [OPTIONS] LTYPE LNAME SOURCES7UPPDERDIR --comps"
    echo

    echo "OPTIONS:"
    echo
    {
	echo "	--action-when-error=abort|continue*"
	echo "	--debug"
	echo "	--trace"
    }
    echo

    echo "LTYPE:"
    echo
    for k in ${(k)LTYPES}; do
	=printf "%-10s	%s\n" "$k" "${LTYPES[$k]}" | indent
    done
    echo
}

i_link_run()
{
    local c=${${0#i_}%_run}
    local opt
    local next
    local action_when_error=continue
    local -a targets

    local ltype
    local lname
    local root
    local target
    local p
    local v
    local p0

    local debug
    local quit_after

    local r

    while true; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		1=( "$opt" "$next" "$@" )
		;;
	    (--quit-after)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		else
		    case "$2" in
			(optparse|prepare) quit_after="--quit-after=$2" ;;
			(*) -E- "$c: unexpected value for $opt" ;;
		    esac
		fi
		shift 2
		;;
	    (--action-when-error)
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $1 is not given"
		else
		    case $2 in
			(abort|continue) action_when_error="$2";;
			(*) -E- "$c: unexpected value for $1: $2";;
		    esac
		fi
		shift 2
		;;
	    (--debug)
		debug=yes
		shift
		;;
	    (--trace|-x)
		set -x
		shift
		;;
	    (-*|--*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    ltype=$1
    shift

    if [[ -z "${ltype}" ]]; then
	-E- "$c: no LTYPE is given"
    elif ! member "$ltype" ${(k)LTYPES}; then
	-E- "$c: no such link type: $ltype"
    fi

    lname=$1
    shift
    if [[ -z "${lname}" ]]; then
	-E- "$c: no LNAME is given"
    elif [[ "${lname}" == */* ]]; then
	-E- "$c: / is not acceptable as LNAME: ${lname}"
    fi

    root=$1
    shift
    if [[ -z "${root}" ]]; then
	-E- "$c: no SOURCES7UPPDERDIR is given"
    elif ! [[ -e "${root}" ]]; then
	-E- "$c: no such dentry: ${root}"
    elif ! [[ -d "${root}" ]]; then
	-E- "$c: no such directory: ${root}"
    elif ! [[ -e "${root}/${P_sources}" ]]; then
	-E- "$c: no such dentry: ${root}/${P_sources}"
    elif ! [[ -d "${root}/${P_sources}" ]]; then
	-E- "$c: no such directory: ${root}/${P_sources}"
    fi

    for target in "$@"; do
	if ! [[ "${target}" == */* ]]; then
	    -E- "$c: / is not found in a PACKAGE/VERSION arguemnt: ${target}"
	fi
	p=${target:h}
	v=${target:t}
	p0=$(name_prefix $p)
	if ! [[ -e "${root}/${P_sources}/${p0}/$p/$v" ]]; then
	    if [[ "${action_when_error}" == 'abort' ]]; then
		-E- "$c: no such target directory: ${root}/${P_sources}/${p0}/$p/$v"
	    else
		-W- "$c: no such target directory: ${root}/${P_sources}/${p0}/$p/$v"
	    fi
	else
	    targets+=$target
	fi
    done

    r=0
    for target in ${target[@]}; do
	l_run_${ltype} "${lname}" "${root}" "${target}" || r=2
    done
    return $r
}

LTYPES[dists]="Links representing a distribution in sources7 upper directory structure"
LTYPES[alias]="Links representing a distribution in sources7 lower directory structure"

l_run_dists()
{
    local lname=$1
    shift

    local root=$1
    shift

    local target=$1
    shift

    local dist
    local p
    local v
    local p0

    p=${target:h}
    v=${target:t}
    p0=$(name_prefix $p)

    if ! mkdir -p "${root}/${P_dists}/${lname}/${p0}"; then
	-E- "Failed to create a directory: ${root}/${P_dists}/${lname}/${p0}"
    fi

    dist="${root}/${P_dists}/${lname}/${p0}/$p"
    local key="${prefix}-ref-dists-${lname}"
    : &&
	{ [[ -e "${dist}" ]] || ln -f -s -r "${root}/${P_sources}/${p0}/$p/$v" "${dist}" } &&
	setfattr -n user.${key} -v "${c_version}" "${root}/${P_sources}/${p0}/$p/$v"
}

l_run_alias()
{
    local lname=$1
    shift

    local root=$1
    shift

    local target=$1
    shift

    local dist
    local p
    local v
    local p0

    p=${target:h}
    v=${target:t}

    p0=$(name_prefix $p)
    dist="${root}/${P_sources}/${p0}/$p/"'^'"${lname}"
    local key="${prefix}-ref-alias-${lname}"
    : &&
	{ [[ -e "${dist}" ]] || ln -f -s -r "${root}/${P_sources}/${p0}/$p/$v" "${dist}" } &&
	setfattr -n user.${key} -v "${c_version}" "${root}/${P_sources}/${p0}/$p/$v"
}

#
#
# Subcommand: bundle
#
#
ICMD+=bundle
ICMD_DESC[bundle]="make bundles"

i_bundle_help()
{
    local k

    echo "$SELF bunlde [OPTIONS] SRPMIX7DIR BUNDLE [BUNDLE_ARGS...]"
    echo

    echo "OPTIONS:"
    echo
    {
	echo "	--action-when-error=abort|continue*"
	echo "	--debug"
	echo "	--quit-after=optparse|prepare"
	echo "	--trace"
	echo "	--update"
    }

    echo

    echo "BUNDLE:"
    echo
    for k in ${(k)BUNDLES}; do
	=printf "%-10s	%s\n" "$k" "${BUNDLES[$k]}" | indent
    done
    echo

}

typeset -A BUNDLE_VERSION

uctags_desc="%s for %s generated by universal ctags default option"
BUNDLES[uctags_tags_pre_build]=$(printf "${uctags_desc}" tags pre_build)
BUNDLE_VERSION[uctags_tags_pre_build]="0.0.0"
REQUIREMENTS[bundle_uctags_tags_pre_build]="${UCTAGS}"

BUNDLES[uctags_tags_srpm_spec]=$(printf "${uctags_desc}" tags srpm.spec)
BUNDLE_VERSION[uctags_tags_srpm_spec]="0.0.0"
REQUIREMENTS[bundle_uctags_tags_srpm_spec]="${UCTAGS}"

BUNDLES[uctags_tags_archives]=$(printf "${uctags_desc}" tags archives)
BUNDLE_VERSION[uctags_tags_archives]="0.0.0"
REQUIREMENTS[bundle_uctags_tags_archives]="${UCTAGS}"

BUNDLES[uctags_TAGS_pre_build]=$(printf "${uctags_desc}" TAGS pre_build)
BUNDLE_VERSION[uctags_TAGS_pre_build]="0.0.0"
REQUIREMENTS[bundle_uctags_TAGS_pre_build]="${UCTAGS}"

BUNDLES[uctags_TAGS_srpm_spec]=$(printf "${uctags_desc}" TAGS srpm.spec)
BUNDLE_VERSION[uctags_TAGS_srpm_spec]="0.0.0"
REQUIREMENTS[bundle_uctags_TAGS_srpm_spec]="${UCTAGS}"

BUNDLES[uctags_TAGS_archives]=$(printf "${uctags_desc}" TAGS archives)
BUNDLE_VERSION[uctags_TAGS_archives]="0.0.0"
REQUIREMENTS[bundle_uctags_TAGS_archives]="${UCTAGS}"

b_run_uctags_tags_pre_build()
{
    b_run_uctags_tags_common ${p_pre_build} "$@"
}

b_run_uctags_tags_srpm_spec()
{
    b_run_uctags_tags_common ${p_srpm_spec} "$@"
}

b_run_uctags_tags_archives()
{
    b_run_uctags_tags_common ${p_archives} "$@"
}

b_run_uctags_TAGS_pre_build()
{
    b_run_uctags_tags_common ${p_pre_build} "$@"  -e
}

b_run_uctags_TAGS_srpm_spec()
{
    b_run_uctags_tags_common ${p_srpm_spec} "$@" -e
}

b_run_uctags_TAGS_archives()
{
    b_run_uctags_tags_common ${p_archives} "$@" -e
}

b_run_uctags_tags_common()
{
    local subtarget=$1
    shift

    if [[ "$1" == --update ]]; then
	shift
    fi

    local d=$1
    local t=$2
    shift 2

    local o
    local flag
    local tname

    if member -e "$@"; then
	tname=TAGS
    else
	tname=tags
    fi

    o=$t/${tname}

    if [[ -e "$d/${subtarget}" ]]; then
	if [[ -d "${d}/${subtarget}" ]]; then
	    flag=-R
	fi

	rm -f ${o}
	${UCTAGS} -o $o ${flag} "$@" $d/${subtarget} || throw Ctags
	if member -e "$@"; then
	    sed -i -e 's|^'"$d"'|../..|' $o || throw Sed
	else
	    sed -i -e 's|^\([^!][^\t]*\)	'$d'|\1	../..|' $o || throw Sed
	fi
    else
	return 1
    fi
    return 0
}

i_bundle_run()
{
    local c=${${0#i_}%_run}
    local opt
    local next
    local action_when_error=continue

    local b
    local d
    local -a args
    local s
    local r

    local update
    local debug
    local quit_after

    while true; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		1=( "$opt" "$next" "$@" )
		;;
	    (--update)
		update=--update
		shift 1
		;;
	    (--quit-after)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		else
		    case "$2" in
			(optparse|prepare) quit_after="--quit-after=$2" ;;
			(*) -E- "$c: unexpected value for $opt" ;;
		    esac
		fi
		shift 2
		;;
	    (--action-when-error)
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $1 is not given"
		else
		    case $2 in
			(abort|continue) action_when_error="$2";;
			(*) -E- "$c: unexpected value for $1: $2";;
		    esac
		fi
		shift 2
		;;
	    (--debug)
		debug=yes
		shift
		;;
	    (--trace|-x)
		set -x
		shift
		;;
	    (-*|--*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done


    d=$1
    if [[ -z "$d" ]]; then
	-E- "$c: no target directory given"
    elif [[ ! -e "$d" ]]; then
	-E- "$c: no such dentry: $d"
    elif [[ ! -d "$d" ]]; then
	-E- "$c: not a directory: $d"
    else
	shift 1
    fi

    if [[ ! -e $d/${p_bundles} ]]; then
	-E- "$c: no such dentry: $d/${p_bundles}"
    elif [[ ! -d $d/${p_bundles} ]]; then
	-E- "$c: not a directory: $d/${p_bundles}"
    elif [[ ! -w $d/${p_bundles} ]]; then
	-E- "$c: not a writable directory: $d/${p_bundles}"
    fi

    if [[ ! -e "$d/$p_status" ]]; then
	-E- "$c: no $p_status found in $d"
    elif [[ ! -r "$d/$p_status" ]]; then
	-E- "$c: cannot read $d/$p_status"
    fi

    case $(< $d/$p_status) in
	(${s_successful})
	;;
	(${s_incomplete}*)
	;;
	(${s_bug}*)
	    -E- "$c: don't make bundle for a directory having BUG status" ;;
	(*)
	    -E- "$c: don't make bundle for a directory having unknown status" ;;
    esac

    b=$1
    if [[ -z "$b" ]]; then
	-E- "$c: no bundle name given"
    elif ! member "$b" ${(k)BUNDLES}; then
	-E- "$c: no such bundle: $b"
    else
	shift 1
    fi

    check_requirements bundle $b

    if [[ "${debug}" == 'yes' ]]; then
	echo srpmix7dir: $d
	echo bundle: $b
    fi

    args=( "$@" )

    if [[ "$quit_after" == "optparse" ]]; then
	exit 0
    fi

    if [[ -f ${d}/${p_bundles}/${b}/$p_bundle_status ]]; then
	if [[ -z "${update}" ]]; then
	    case $(< ${d}/${p_bundles}/${b}/$p_bundle_status) in
		($s_bundle_successful)
		    return 0
	    esac
	fi
    fi

    {
	local t

	if ! t=$(mktemp --tmpdir --directory ${SELF}-BUNDLE-${b}.XXXXXXXXXX) ; then
	    throw Creation
	elif [[ "${debug}" == "yes" ]]; then
	    echo tmpdir: $t
	fi

	if ! b_prepare $t; then
	    throw Preparation
	else
	    {
		: &&
		    echo "${b}" > $t/$p_bundle_uname/bundle &&
		    echo ${BUNDLE_VERSION[${b}]} > $t/$p_bundle_uname/b_version &&
		    echo "${args[@]}" > $t/$p_bundle_uname/b_args
	    } || throw Preparation
	fi

	if [[ "$quit_after" == "prepare" ]]; then
	    exit 0
	fi
	b_run_${b} ${update} ${d} ${t} "$args[@]" > $t/$p_bundle_log/b.log 2>&1
    } always {
	s=$?
	if catch 'Preparation'; then
	    r=1
	elif catch 'Ctags'; then
	    cat $t/$p_bundle_log/b.log 1>&2
	    r=2
	elif catch '*'; then
	    cat $t/$p_bundle_log/b.log 1>&2
	    r=2
	elif [[ $s != 0 ]]; then
	    cat $t/$p_bundle_log/b.log 1>&2
	    r=1
	else
	    r=0
	    if [[ -e "${d}/${p_bundles}/${b}" ]]; then
		mv "${d}/${p_bundles}/${b}" "${d}/${p_bundles}/.${b}"
	    fi
	    mv $t "${d}/${p_bundles}/${b}"
	    rm -rf "${d}/${p_bundles}/.${b}"
	    b_commit "${d}/${p_bundles}/${b}" "${s_bundle_successful}"
	fi

	if [[ -e "$t" && "${debug}" != "yes" ]]; then
	    rm -rf "$t"
	fi
    }

    return $r
}

b_commit()
{
    local d=$1
    local msg=$2
    echo "$msg" > $d/.$p_status
    mv $d/.$p_status $d/$p_status
    make_all_readable $d
}

b_prepare()
{
    local d=$1
    local elt

    for elt in $p_bundle_uname $p_bundle_log; do
	if ! mkdir ${d}/${elt}; then
	    return 1
	fi
    done

    elt=.$p_status
    echo "${s_bundle_unknown}" > ${d}/${elt}

    return 0
}


#
#
# Subcommand: help
#
#
ICMD+=help
ICMD_DESC[help]="show help message for subcommand"

i_help_help()
{
    echo "$SELF help [SUBCOMMAND]"
}

i_help_run()
{
    local i=${${0#i_}%_run}
    local c=$1

    if [[ -z "$c" ]]; then
	-E-  "$i: no subcommand given"
    elif subcommand_exist_p "$c"; then
	echo "${(U)c} subcommand usage:"
	subcommand_help $c | indent
    else
	-E-  "$i: no such subcommand: $c"
    fi
}

#
#
# Subcommand: deploy
#
#
ICMD+=deploy
ICMD_DESC[deploy]="deploy a set of source code"
typeset -A CRADLE_TYPE

i_deploy_help()
{
    local k

    echo "$SELF deploy [OPTIONS] CRADLE-FILE DEST-DIR"
    echo
    echo "OPTIONS:"
    {
	echo "	--debug"
	echo "	--trace"
	echo "	--skip-incomplete-ones|-s"
    } | indent
    echo
    echo "Cradle file format:"
    {
	=printf "name=NAME\n"
	=printf "type=CRADLE_TYPE\n"
    } | indent
    echo
    echo "CRADLE_TYPE:"
    for k in ${(k)CRADLE_TYPE}; do
	=printf "%-10s	%s\n" "$k" "${CRADLE_TYPE[$k]}"
    done  | indent
}

i_deploy_run()
{
    local -a args
    args=( "$@" )
    local c=${${0#i_}%_run}
    local opt
    local next
    local debug
    local elt

    local cradle_file
    local -a cradle_conf
    local k v

    local cradle_name
    local cradle_type

    local sources7
    local fn
    local r

    local force_skipping

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--debug|-d)
		debug=yes
		shift
		;;
	    (--skip-incomplete-ones|-s)
		force_skipping=-s
		shift
		;;
	    (--trace|-x)
		set -x
		shift
		;;
	    (--*)
		-E- "$c: unknown long option: $1"
		break
		;;
	    (-*)
		-E- "$c: unknown short option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    if [[ -z "$1" ]]; then
	-E- "$c: too few arguemnt, no cradle file is given"
    elif [[ ! -e "$1" ]]; then
	-E- "$c: no such directory entry: $1"
    elif [[ ! -f "$1" ]]; then
	-E- "$c: not a file: $1"
    elif [[ ! -r "$1" ]]; then
	-E- "$c: not readable: $1"
    fi

    cradle_file=$1
    shift

    for elt in ${(@f)"$(< ${cradle_file})"[@]}; do
	case $elt in
	    (\#*)
		:
		;;
	    (name=*)
		cradle_name=${elt#name=}
		if [[ ${cradle_name} == */* ]]; then
		    -E-  "${c}: cradle name should not contain '/' (in ${cradle_file})"
		fi
		;;
	    (type=*)
		cradle_type=${elt#type=}
		if ! member "$cradle_type" ${(k)CRADLE_TYPE}; then
		    -E- "$c: no such cradle type: $cradle_type"
		fi
		check_requirements cradle ${cradle_type}
		;;
	    (${cradle_type}_*=*)
		k=${${elt#"${cradle_type}_"}%%=*}

		if [[ -z ${cradle_type} ]]; then
		    -E- "${c}: $k must be defined AFTER type= (in $cradle_file)"
		elif [[ -z ${cradle_name} ]]; then
		    -E- "${c}: $k must be defined AFTER name= (in $cradle_file)"
		fi
		v=${${${elt#*=}//"%{name}"/"${cradle_name}"}//"%{type}"/${cradle_type}}
		cradle_conf+=( "$k" "$v" )
		;;
	    (*)
		-E- "${c}: unexpected line <$elt> (in $cradle_file)"
		;;
	esac
    done

    if [[ -z "$1" ]]; then
	-E- "$c: too few arguemnt, no sources7 directory is given"
    elif [[ ! -e "$1" ]]; then
	-E- "$c: no such directory entry: $1"
    elif [[ ! -d "$1" ]]; then
	-E- "$c: not a directory: $1"
    elif [[ ! -r "$1" ]]; then
	-E- "$c: not readable: $1"
    elif [[ ! -x "$1" ]]; then
	-E- "$c: not executable: $1"
    elif [[ ! -w "$1" ]]; then
	-E- "$c: not writable: $1"
    else
	sources7=$1
	shift
    fi

    fn=d_${cradle_type}_deploy

    {
	local cradledir=${sources7}/${P_cradles}/${cradle_name}
	integer -l cradlefd

	if ! mkdir -p ${cradledir}; then
	    -E- "${c}: failed to create \"${P_cradles}\"(${cradledir}) directory for ${cradle_name}"
	fi

	if ! lock cradlefd ${cradledir}; then
	    -E- "${c}: other process may work on ${cradle_name} (faild to lock ${cradledir})"
	fi

	local cradle=${sources7}/${P_cradles}/${cradle_name}
	local cradle_sources=${cradle}/${P_cradle_sources}
	local cradle_bundles=${cradle}/${P_cradle_bundles}
	local cradle_log=${cradle}/${P_cradle_log}
	local sources=${sources7}/${P_sources}

	if ! mkdir -p  ${cradle_log}; then
	    -E- "${c}: failed to create ${cradle_sources}"
	fi

	{
	    if ! mkdir -p  ${cradle_sources}; then
		-E- "${c}: failed to create ${cradle_sources}"
	    fi

	    if ! mkdir -p  ${cradle_bundles}; then
		-E- "${c}: failed to create ${cradle_bundles}"
	    fi

	    if ! mkdir -p ${sources}; then
		-E- "${c}: failed to create ${sources}"
	    fi

	    progress_init "${cradle_name}" ${cradle_log}/d_progress.log ${cradle_log}/d_critical.log
	    "${fn}" ${cradle_name} cradle_conf ${sources7} ${force_skipping}
	    r=$?
	    progress_fini "${cradle_name}"

	    {
		local -A conf
		echo "name=${cradle_name}"
		echo "type=${cradle_type}"

		conf=( ${cradle_conf[@]} )
		for k in ${(k)conf}; do
		    echo "${cradle_type}_${k}=${conf[$k]}"
		done

	    } > ${cradle}/${P_cradle_conf}

	} 2>&1 | tee ${cradle_log}/d.log

	unlock $cradlefd
    }
}

CRADLE_TYPE[dir]="flatten directory"
REQUIREMENTS[cradle_dir]="flock setfattr"

typeset -A PROGRESS_REPORT_CHAR

readonly -x r_unknown_file='?'
PROGRESS_REPORT_CHAR[$r_unknown_file]="unknown file for expanding"

readonly -x r_broken_input='<'
PROGRESS_REPORT_CHAR[$r_broken_input]="MAYBE INPUT FILE IS BROKEN"

readonly -x r_unexpected_env='>'
PROGRESS_REPORT_CHAR[$r_broken_env]="UNEXPECTED RUNTIME ENVIRONMENT"

readonly -x r_locked='_'
PROGRESS_REPORT_CHAR[$r_locked]="cannot get file lock"

readonly -x r_skipped=','
PROGRESS_REPORT_CHAR[$r_skipped]="already successfully deployed"

readonly -x r_forced_skipping=';'
PROGRESS_REPORT_CHAR[$r_forced_skipping]="forced skipping failed one"

readonly -x r_successful='.'
PROGRESS_REPORT_CHAR[$r_successful]="successfully expanded"

readonly -x r_bug='!'
PROGRESS_REPORT_CHAR[$r_bug]="MAYBY A BUG IN EXPAND SUBCOMMAND"

readonly -x r_failed_in_prep='f'
PROGRESS_REPORT_CHAR[$r_failed_in_prep]="failed in %prep"

readonly -x r_unknown='*'
PROGRESS_REPORT_CHAR[$r_unknown]="unknown"

progress_cradle=
progress_source=
integer progress_fd
integer critical_fd

typeset -A progress_counter
typeset -A progress_details

progress_init()
{
    progress_cradle=$1
    local progress_file=$2
    local critical_file=$3
    local k

    exec {progress_fd}> ${progress_file}
    exec {critical_fd}> ${critical_file}

    progress_counter[TOTAL]=0
    progress_counter[MSG]=0
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	progress_counter[$k]=0
    done

    progress_counter[MSG]=0
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	progress_details[$k]=""
    done

    echo "Cradle: [$progress_cradle]"
    echo '======================================================================'
    echo -n START:
    date
    {
	echo Cradle: $cradle
	echo '======================================================================'
	echo -n START:
	date
	echo

    } >&${progress_fd}
}

progress_fini()
{
    progress_cradle=$1
    local k
    local l

    echo
    echo -n END:
    date
    echo
    =printf "%-35s%s %25s\n"   "TOTAL"  " - " "${progress_counter[TOTAL]}"
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	=printf "%-35s(%c) %25s\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k" "${progress_counter[$k]}"
    done | sort

    echo
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	if [[ -z "${progress_details[$k]}" ]]; then
	    continue
	else
	    case $k in
		($r_skipped|$r_forced_skipping|$r_successful)
		continue
		;;
	    esac
	fi
	=printf "%s(%c)\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k"
	echo '----------------------------------------------------------------------'
	for l in ${(f)${progress_details[$k]}}; do
	    echo $l
	done
    done

    {
	echo
	echo -n END:
	date
	echo
	=printf "%-35s%s %25s\n"   "TOTAL"  " - " "${progress_counter[TOTAL]}"
	for k in ${(k)PROGRESS_REPORT_CHAR}; do
	    =printf "%-35s(%c) %25s\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k" "${progress_counter[$k]}"
	done | sort

	echo
	for k in ${(k)PROGRESS_REPORT_CHAR}; do
	    if [[ -z "${progress_details[$k]}" ]]; then
		continue
	    else
		case $k in
		    ($r_skipped|$r_forced_skipping|$r_successful)
			continue
			;;
		esac
	    fi
	    =printf "%s(%c)\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k"
	    echo '----------------------------------------------------------------------'
	    for l in ${(f)${progress_details[$k]}}; do
		echo $l
	    done
	done
    } >&${progress_fd}


    exec {critical_fd}>&-
    exec {progress_fd}>&-
}

progress_source()
{
    progress_source=$1
}

progress_newline_maybe()
{
    if [[ $1 -gt 68 ]]; then
	echo "|"
    else
	return 1
    fi
}

progress_report()
{
    local s=$1
    local dloc=$2

    echo -n "$s"
    echo -n "$s" >&${progress_fd}

    (( progress_counter[TOTAL] += 1 ))
    (( progress_counter[MSG] += 1 ))
    (( progress_counter[$s] += 1))

    if [[ -n "${dloc}" ]]; then
	progress_details[$s]+=$(=printf "%50s => %-20s\n" "${progress_source:t}" "${dloc:t}")"\n"
    else
	progress_details[$s]+=$(=printf "%50s\n" "${progress_source:t}")"\n"
    fi

    case "$s" in
	(${r_broken_input}|${r_unexpected_env}|${r_bug}|"${r_unknown}")
	    echo "$s(${PROGRESS_REPORT_CHAR[$s]})" "${progress_source}" "=>" "${dloc}"
	    echo "$s(${PROGRESS_REPORT_CHAR[$s]})" "${progress_source}" "=>" "${dloc}" >&${critical_fd}
	    ;;
    esac

    progress_newline_maybe ${progress_counter[MSG]} && progress_counter[MSG]=0
    progress_newline_maybe ${progress_counter[MSG]} >&${progress_fd} && progress_counter[MSG]=0
}

d_dir_deploy()
{
    local self=dir
    local cradle_name=$1
    local -A conf
    conf=( ${(P)2[@]} )
    local sources7=$3
    shift 3
    local force_skipping

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (-s)
		force_skipping=yes
		shift
		;;
	esac
    done

    local cradle=${sources7}/${P_cradles}/${cradle_name}
    local cradle_sources=${cradle}/${P_cradle_sources}
    local cradle_log=${cradle}/${P_cradle_log}
    local sources=${sources7}/${P_sources}

    local dir=${conf[dir]}
    local src_name
    local src_version
    local expander
    local src
    local dest
    local r

    if [[ -z "${dir}" ]]; then
	-E- "${c}: ${self}_dir is not given in cradle ${cradle_name}"
    elif ! [[ -e "${dir}" ]]; then
	-E- "$c: no such directory entry: ${dir} specified in cradle ${cradle_name}"
    elif ! [[ -r "${dir}" ]]; then
	-E- "$c: cannot read directory: ${dir} specified in cradle ${cradle_name}"
    elif ! [[ -x "${dir}" ]]; then
	-E- "$c: cannot traverse directory: ${dir} specified in cradle ${cradle_name}"
    fi

    for src in ${dir}/*; do
	progress_source "${src}"

	case "${src}" in
	    (*.src.rpm)
		expander=srpm
		;;
	    (*)
		progress_report ${r_unknown_file}
		continue
		;;
	esac

	if ! src_name=$(pname_name ${expander} $src); then
	    progress_report ${r_broken_input}
	    continue
	fi
	if ! src_version=$(pname_version ${expander} $src); then
	    progress_report ${r_broken_input}
	    continue
	fi

	dest=${sources}/$(name_prefix "${src_name}")/${src_name}/${src_version}--${expander}

	if ! mkdir -p ${dest}; then
	    -W- "${c}: skip [${cradle_name}]${src} because creating dir:${dest} is failed"
	    progress_report "${r_unexpected_env}" ${dest}
	    continue
	fi

	{
	    integer -l destfd
	    local s=${dest}/${p_status}

	    if ! lock destfd ${dest}; then
		-W- "${c}: other process may work on [${cradle_name}]${src}/${expander} (faild to lock ${dest})"
		progress_report "${r_locked}" ${dest}
		throw "${r_locked}"
	    fi

	    if [[ -f ${s} ]]; then
		case $(< ${s}) in
		    (${s_successful})
			progress_report "${r_skipped}" ${dest}
			throw "${r_skipped}"
			;;
		    (${s_incomplete}*)
			if [[ "${force_skipping}" == yes ]]; then
			    progress_report "${r_forced_skipping}" ${dest}
			    throw "${r_forced_skipping}"
			fi
			;;
		esac
	    fi

	    rm -rf ${dest}/*(N)
	    (
		# TODO: TIMEOUT
		subcommand_run expand --stype file --sloc $src --dtype dir --dloc ${dest} ${expander}
	    )
	    r=$?

	    case $r in
		(0) progress_report "${r_successful}" ${dest} ;;
		(1) progress_report "${r_bug}" ${dest} ;;
		(2) progress_report "${r_failed_in_prep}" ${dest};;
		(*) progress_report "${r_unknown}" ${dest};;
	    esac
	} always {
	    if catch '*'; then
		:
	    fi

	    {
		local base=${cradle_sources}/$(name_prefix "${src_name}")/${src_name}
		# e.g. ln -s -t /tmp/8 -r /tmp/9/a
		: &&
		    mkdir -p "${base}" &&
		    ln -f -s -t "${base}" -r ${dest}
	    }

	    {
		# attr -q -l tmp/sources/r/rhs-hadoop-install/2_29-1.el6rhs--srpm
		local key="${prefix}-ref-cradle-${cradle_name}"
		setfattr -n user.${key} -v "${c_version}" ${dest}
	    }
	    if [[ -n "${destfd}" ]]; then
		unlock $destfd
	    fi
	}
    done

    return 0
}


CRADLE_TYPE[yum]="yumrepo (not implemented yet)"
REQUIREMENTS[cradle_yumrepo]="yum repoquery"

#
#
# Subcommand: podman-image-build
#
#
typeset -A DISTRO_stype
typeset -A DISTRO_expander
typeset -A DISTRO_srepos
typeset -A DISTRO_brepos
typeset -A DISTRO_docker_files
typeset -A DISTRO_hook_scripts

#
# ceontos8
#
DISTRO_stype[centos8]=dds
DISTRO_expander[centos8]=srpm
DISTRO_srepos[centos8]="
AppStream-source
BaseOS-source
centosplus-source
extras-source
"
DISTRO_brepos[centos]="
AppStream
BaseOS
centosplus
extras
"
DISTRO_docker_files[centos8]='
FROM docker.io/library/centos:8
RUN dnf -y install zsh rpm-build yum-utils
RUN dnf -y install gcc annobin
RUN dnf config-manager --set-enabled PowerTools

#include "srpmix7.dockerfile"

RUN dnf repolist --all
RUN dnf makecache

COPY ./hooks /hooks
COPY ./srpmix7 /usr/bin/srpmix7
'

#
# centos7
#
DISTRO_stype[centos7]=yds
DISTRO_expander[centos7]=srpm
DISTRO_srepos[centos7]='
base-source
centos-sclo-rh-source
centosplus-source
extras-source
updates-source
'
DISTRO_brepos[centos7]='
base
centos-sclo-rh
centosplus
extras
updates
'
DISTRO_docker_files[centos7]='
FROM docker.io/library/centos:7
RUN yum -y install zsh rpm-build yum-utils

RUN yum -y install centos-release-scl-rh

#include "srpmix7.dockerfile"

RUN yum repolist all
RUN yum makecache

RUN yum -y install cpp

COPY ./hooks /hooks
COPY ./srpmix7 /usr/bin/srpmix7
'

#
# fedora31
#
DISTRO_stype[fedora31]=dds
DISTRO_expander[fedora31]=srpm
DISTRO_srepos[fedora31]="
fedora-modular-source
fedora-source
updates-modular-source
updates-source
updates-testing-modular-source
updates-testing-source
"
DISTRO_brepos[fedora31]="
fedora
fedora-cisco-openh264
fedora-modular
updates
updates-modular
updates-testing
updates-testing-modular
"
DISTRO_docker_files[fedora31]='
FROM docker.io/library/fedora:31
RUN dnf -y install zsh rpm-build dnf-plugins-core
RUN dnf -y install gcc annobin

#include "srpmix7.dockerfile"

RUN dnf repolist --all
RUN dnf -y makecache

COPY ./hooks /hooks
COPY ./srpmix7 /usr/bin/srpmix7
'

DISTRO_hook_scripts[fedora31/expander_srpm/before-builddep]='
#!/bin/zsh
typeset -a REPOS
REPOS=('"
${DISTRO_brepos[fedora31]}
"')
dnf config-manager --set-disabled ''*''
for r in "${REPOS[@]}"; do
    dnf config-manager --set-enabled $r
done
'

DISTRO_hook_scripts[fedora31/stype_dds/before-download]='
#!/bin/zsh
typeset -a REPOS
REPOS=('"
${DISTRO_srepos[fedora31]}
"')
dnf config-manager --set-disabled ''*''
for r in "${REPOS[@]}"; do
    dnf config-manager --set-enabled $r
done
'

#
# rhel8
#
DISTRO_stype[rhel8]=dds
DISTRO_expander[rhel8]=srpm
DISTRO_srepos[rhel8]='
codeready-builder-for-rhel-8-x86_64-source-rpms
rhel-8-for-x86_64-appstream-source-rpms
rhel-8-for-x86_64-baseos-source-rpms
'
DISTRO_brepos[rhel8]='
codeready-builder-for-rhel-8-x86_64-rpms
rhel-8-for-x86_64-appstream-rpms
rhel-8-for-x86_64-baseos-rpms
'
DISTRO_docker_files[rhel8]='
FROM registry.redhat.io/ubi8/ubi
RUN dnf -y install zsh rpm-build yum-utils
RUN dnf -y install gcc annobin
RUN dnf config-manager --set-enabled rhel-8-for-x86_64-appstream-rpms
RUN dnf config-manager --set-enabled codeready-builder-for-rhel-8-x86_64-rpms

#include "srpmix7.dockerfile"

RUN dnf repolist --all
RUN dnf makecache

COPY ./hooks /hooks
COPY ./srpmix7 /usr/bin/srpmix7
'

#
# rhel7
#
DISTRO_stype[rhel7]=yds
DISTRO_expander[rhel7]=srpm
DISTRO_srepos[rhel7]='
rhel-7-server-source-rpms
rhel-7-server-optional-source-rpms
rhel-7-server-extras-source-rpms
'
DISTRO_brepos[rhel7]='
rhel-7-server-rpms
rhel-7-server-optional-rpms
rhel-7-server-extras-rpms
'
DISTRO_docker_files[rhel7]='
FROM registry.redhat.io/ubi7/ubi
RUN yum -y install zsh rpm-build yum-utils
RUN yum -y install gcc annobin
RUN yum -y install git
RUN yum repolist all
RUN yum-config-manager --enable rhel-7-server-optional-rpms
RUN yum-config-manager --enable rhel-7-server-extras-rpms

#include "srpmix7.dockerfile"

RUN yum makecache

COPY ./hooks /hooks
COPY ./srpmix7 /usr/bin/srpmix7
'

podman_load_distros()
{
    local c
    for c in /etc/srpmix7/distro.d/*.distro(N) ~/.srpmix7/distro.d/*.distro(N); do
	if [[ ! -r "$c" ]]; then
	    continue
	fi
	source "$c"
    done
}
podman_load_distros

ICMD+=podman-image-build
ICMD_DESC[podman-image-build]="build container image for expanding source code"

i_podman-image-build_help()
{
    local k
    =printf "%s\\\\\n" "$SELF podman-image-build DISTRO"
    =printf "%s\\\\\n" "$SELF podman-image-build [OPTIONS]"
    echo "OPTIONS:"
    {
	echo "	--dont-overwrite|-a"
	echo "	--list-buildable|-l"
    }

    echo "DISTRO:"
    for k in ${(k)DISTRO_docker_files}; do
	=printf "%-10s	%s\n" "$k" | indent
    done
}

i_podman-image-build_run()
{
    local k
    local c=${${0#i_}%_run}
    local opt
    local next
    local dont_overwrite=0

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--dont-overwrite|-a)
		dont_overwrite=1
		shift 1
		;;
	    (--list-buildable|-l)
		for k in ${(k)DISTRO_docker_files}; do
		    echo $k
		done
		return 0
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    if [[ $# -ne 1 ]]; then
	-E- "$c: need name of distro"
    fi

    local distro=$1
    if podman_has_image ${distro} && [[ "${dont_overwrite}" -eq 1 ]]; then
	return 0
    fi

    if [[ -z "${DISTRO_docker_files[$distro]}" ]]; then
	-E%- "$c: no buildable distro named %s" "$distro"
    fi

    local stype=${DISTRO_stype[$distro]}
    if [[ -z "${stype}" ]]; then
	-E%- "$c: no stype given for distro %s" "$distro"
    fi

    local expander=${DISTRO_expander[$distro]}
    if [[ -z "${expander}" ]]; then
	-E%- "$c: no expander given for distro %s" "$distro"
    fi

    local tmpdir=$(mktemp -d --suffix=srpmix7-$c-${distro})
    if ! [[ "$tmpdir" =~ '/tmp/.*' ]]; then
	-E- "$c: unexpected temorary file name: $tmpdir"
    fi

    echo "${DISTRO_docker_files[$distro]}" > $tmpdir/Dockerfile.in
    echo "ENV SRPMIX_STYPE ${stype}" >> $tmpdir/srpmix7.dockerfile
    echo "ENV SRPMIX_EXPANDER ${expander}" >> $tmpdir/srpmix7.dockerfile
    local r

    case "$stype" in
	(dds)
	    for r in $(echo ${DISTRO_srepos[$distro]}); do
		echo "RUN dnf config-manager --set-enabled $r"
	    done >> $tmpdir/srpmix7.dockerfile
	    for r in $(echo ${DISTRO_brepos[$distro]}); do
		echo "RUN dnf config-manager --set-enabled $r"
	    done >> $tmpdir/srpmix7.dockerfile
	    ;;
	(yds)
	    for r in $(echo ${DISTRO_srepos[$distro]}); do
		echo "RUN yum-config-manager --enable $r"
	    done >> $tmpdir/srpmix7.dockerfile
	    for r in $(echo ${DISTRO_brepos[$distro]}); do
		echo "RUN yum-config-manager --enable $r"
	    done >> $tmpdir/srpmix7.dockerfile
	    ;;
	(*)
	    -E- "$c: list operatoin is not supported in %s stype"
	    ;;
    esac
    cp $SELF_FULL $tmpdir/srpmix7

    mkdir $tmpdir/hooks
    mkdir $tmpdir/hooks/{stype_$stype,expander_$expander}

    local hook
    local hook_file
    for k in ${(k)DISTRO_hook_scripts}; do
	if [[ "$k" =~ "^${distro}/stype_${stype}/([-a-zA-Z_0-9]+)" ]]; then
	    hook=${match[1]}
	    hook_file=$tmpdir/hooks/stype_$stype/$hook
	elif [[ "$k" =~ "^${distro}/expander_${expander}/([-a-zA-Z_0-9]+)" ]]; then
	    hook=${match[1]}
	    hook_file=$tmpdir/hooks/expander_$expander/$hook
	else
	    continue
	fi
	echo "${DISTRO_hook_scripts[$k]}" > $hook_file
	chmod a+x $hook_file
    done

    (
	cd $tmpdir
	podman build -f $tmpdir/Dockerfile.in -t srpmix7-${distro} . \
	    && rm -rf "$tmpdir"
    )

    return $?
}

#
#
# Subcommand: podman-srpm-pkglist
#
#
ICMD+=podman-srpm-pkglist
ICMD_DESC[podman-srpm-pkglist]="list packages"
i_podman-srpm-pkglist_help()
{
    =printf "%s\\\\\n" "$SELF podman-srpm-pkglist [--expand-args=DISTDIR] DISTRO..."
}

i_podman-srpm-pkglist_run()
{
    local c=${${0#i_}%_run}
    local opt
    local next
    local expand_args

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--expand-args)
		if [[ -z "$2" ]]; then
		    -E- "$c: DISTDIR for --expand-args is not given"
		fi
		expand_args=$2
		shift 2
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    local distro=$1
    if [[ -z "$distro" ]]; then
	-E- "$c: DISTRO is not given in command line"
    fi

    for distro in "$@"; do
	if ! podman_has_image ${distro}; then
	    -E%- "$c: no container image for %s (%s)" "${distro}" "srpmix7-${distro}"
	fi

	local stype=$(podman inspect  --format "{{range .Config.Env}}{{println .}}{{end}}" srpmix7-${distro} \
			  | sed -n -e 's/SRPMIX_STYPE=\(.*\)/\1/p')
	if [[ -z "$stype" ]]; then
	    -E%- "$c: no stype (SRPMIX_STYPE) in image %s" "srpmix7-${distro}"
	fi

	case "$stype" in
	    (dds)
		local fmt
		if [[ -n "${expand_args}" ]]; then
		    fmt="${distro}"' \1-\2 '"${expand_args}"
		else
		    fmt='\1 \2'
		fi
		podman run --rm srpmix7-"${distro}" dnf -q --showduplicates list '*.src' \
		    | grep -v '^Available Packages.*' \
		    | sed -n -s 's|^\([^ \t]\+\).src[ \t]\+\([^ \t]\+\)[ \t]\+@\?\([^ \t]\+\).*$|'"${fmt}"'|p' \
		    | sort -u
		;;
	    (yds)
		local -A nvr2e
		local srpm nvr n vr epoch
		while read srpm epoch; do
		    nvr2e[$(sed -e 's/\(.*\).src.rpm.*$/\1/'<<<"$srpm")]="$epoch";
		done < <(podman run --rm srpmix7-"${distro}" repoquery \
			 -q -a --show-duplicates \
			 --queryformat "%{sourcerpm} %{epoch}" | sort -u)

		podman run --rm srpmix7-"${distro}" repoquery -q -a -s --show-duplicates \
		    | sed -e 's/\(.*\).src.rpm.*$/\1/' \
		    | { while read nvr; do
			    epoch=${nvr2e[$nvr]}
			    read n vr <<<$(split_n_vr ${nvr})
			    if [[ -n "$epoch" && "$epoch" != 0 ]]; then
				vr="${epoch}:${vr}"
			    fi

			    if [[ -n "${expand_args}" ]]; then
				echo "${distro} ${n}-${vr} ${expand_args}"
			    else
				echo "${n} ${vr}"
			    fi
			done } | sort -u
		;;
	    (*)
		-E- "$c: list operatoin is not supported in $stype stype"
		;;
	esac
    done
}

split_n_vr()
{
    local V=$1
    local n vr
    n=${V%%-[0-9]*}
    vr=${V:((${#n} + 1))}

    if [[ -n "$2" ]]; then
	echo ${2}-${n} $vr
    else
	echo $n $vr
    fi
}

split_by_hyphen()
{
    local V=$1
    local prefix=$2

    local V=$1
    local n vr
    n=${V%%-*}
    vr=${V:((${#n} + 1))}

    if [[ -n "$2" ]]; then
	echo ${2}-${n} $vr
    else
	echo $n $vr
    fi
}

split_n_vr_combinations()
{
    read n vr <<<$(split_by_hyphen $1 $2)
    if [[ -n "$vr" ]]; then
	echo $n $vr
	split_n_vr_combinations $vr $n
    fi
}

#
#
# Subcommand: podman-srpm-repolist
#
#
ICMD+=podman-srpm-repolist
ICMD_DESC[podman-srpm-repolist]="list repositories"
i_podman-srpm-repolist_help()
{
    =printf "%s\\\\\n" "$SELF podman-srpm-repolist DISTRO"
}

i_podman-srpm-repolist_run()
{
    local c=${${0#i_}%_run}
    local opt
    local next

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    local distro=$1
    if [[ -z "$distro" ]]; then
	-E- "DISTRO is not given in command line"
    fi

    if ! podman_has_image ${distro}; then
	-E%- "no container image for %s (%s)" "${distro}" "srpmix7-${distro}"
    fi

    local stype=$(podman inspect  --format "{{range .Config.Env}}{{println .}}{{end}}" srpmix7-${distro} \
		      | sed -n -e 's/SRPMIX_STYPE=\(.*\)/\1/p')
    if [[ -z "$stype" ]]; then
	-E%- "no stype (SRPMIX_STYPE) in image %s" "srpmix7-${distro}"
    fi

    case "$stype" in
	(dds)
	    podman run --rm srpmix7-"${distro}" dnf -q -C repolist --all \
		| grep -v '^repo id' \
		| cut -d ' ' -f 1
	    ;;
	(yds)
	    podman run --rm srpmix7-"${distro}" yum -C repolist all \
		| grep -v '^Loaded plugins:.*' \
		| grep -v '^Loading mirror speeds from cached hostfile.*' \
		| grep -v '^ .*' \
		| grep -v '^repo id' \
		| grep -v '^repolist:' \
		| sed -n -e 's|^[*!]\?\([^/ \t]\+\).*$|\1|p'
	    ;;
	(*)
	    -E%- "repolist operatoin is not supported in %s stype" "$stype"
	    ;;
    esac
}

#
#
# Subcommand: podman-srpm-expand
#
#
ICMD+=podman-srpm-expand
ICMD_DESC[podman-srpm-expand]="expand srpm with podman"

i_podman-srpm-expand_help()
{
    =printf "%s\\\\\n" "$SELF podman-srpm-expand [OPTIONS] DISTRO SRPM DISTDIR "
    echo "OPTIONS:"
    {
	echo "	--dont-overwrite|-a force-overwrite|if-successful[:status]|if-existing[:status]"
	echo "		default: if-successful:0"
	echo "	--overwrite-even-if-incomplete"
	echo "	--xargs=ENVVAR"
    }
}

i_podman-srpm-expand_run()
{
    local c=${${0#i_}%_run}
    local opt
    local next
    local dont_overwrite=if-existing
    local dont_overwrite_status=0
    local overwrite_even_if_incomplete
    local xargs

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--dont-overwrite|-a)
		case "$2" in
		    (force-overwrite)
			dont_overwrite=
			dont_overwrite_status=
			;;
		    (if-successful|if-existing)
			dont_overwrite=${2}
			dont_overwrite_status=0
			;;
		    (if-existing:[0-9]*|if-successful:[0-9]*)
			dont_overwrite=${2%:*}
			dont_overwrite_status=${2#*:}
			;;
		    (*)
			-E- "$c: unknown dont-overwrite condition: $2"
			;;
		esac
		shift 2
		;;
	    (--overwrite-even-if-incomplete)
		overwrite_even_if_incomplete=1
		shift 1
		;;
	    (--xargs)
		xargs=$2
		if [[ -z "${(P)xargs}" ]]; then
		    -E- "$C: value for ${xargs} is not given"
		fi
		shift 2
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    if [[ $# -ne 3 ]]; then
	-E- "$c: three arguments are expected"
    fi

    local distro=$1
    local pkg=$2
    local ddir=$3

    if [[ -z "$distro" ]]; then
	-E- "DISTRO is not given in command line"
    fi
    if [[ -z "$pkg" ]]; then
	-E- "SRPM is not given in command line"
    fi
    if [[ -z "$ddir" ]]; then
	-E- "DESTDIR is not given in command line"
    fi

    if ! podman_has_image ${distro}; then
	-E%- "no container image for %s (%s)" "${distro}" "srpmix7-${distro}"
    fi

    local stype=$(podman inspect  --format "{{range .Config.Env}}{{println .}}{{end}}" srpmix7-${distro} \
		      | sed -n -e 's/SRPMIX_STYPE=\(.*\)/\1/p')
    if [[ -z "$stype" ]]; then
	-E%- "no stype (SRPMIX_STYPE) in image %s" "srpmix7-${distro}"
    fi

    local expander=$(podman inspect  --format "{{range .Config.Env}}{{println .}}{{end}}" srpmix7-${distro} \
			 | sed -n -e 's/SRPMIX_EXPANDER=\(.*\)/\1/p')
    if [[ -z "$expander" ]]; then
	-E%- "no expander (SRPMIX_EXPANDER) in image %s" "srpmix7-${distro}"
    fi

    local msgout=/dev/stdout

    if [[ -n "${xargs}" ]]; then
	mkdir -p ${ddir}/_xargs
	msgout=${ddir}/_xargs/${(P)xargs}.cpuid
	# printf "srpmix7 (%s) " "$c" > "$msgout"
	echo -n "srpmix7 " > "$msgout"
    fi

    {
	{
	    echo -n "expanding $pkg of $distro..."

	    local n=$(name_prefix "${pkg}")
	    local name ver_rel

	    while read name ver_rel; do
		if [[ -n "${ver_rel}" ]]; then
		    local expected_dd=${ddir}/sources/${n}/${name}/${ver_rel}--${expander}
		    case "${dont_overwrite}" in
			(if-existing)
			    if [[ -e ${expected_dd}/${p_successful} ]]; then
				mkdir -p ${expected_dd}/${p_info}/podman-srpm-distro.d
				touch ${expected_dd}/${p_info}/podman-srpm-distro.d/${distro}
				echo "existing as SUCCESSFUL: ${expected_dd}"
				return ${dont_overwrite_status}
			    elif [[ -e ${expected_dd}/${p_incomplete} ]]; then
				mkdir -p ${expected_dd}/${p_info}/podman-srpm-distro.d
				touch ${expected_dd}/${p_info}/podman-srpm-distro.d/${distro}
				echo "existing as INCOMPLETE: ${expected_dd}"
				return ${dont_overwrite_status}
			    fi
			    ;;
			(if-successful)
			    if [[ -e ${expected_dd}/${p_successful} ]]; then
				mkdir -p ${expected_dd}/${p_info}/podman-srpm-distro.d
				touch ${expected_dd}/${p_info}/podman-srpm-distro.d/${distro}
				echo "existing as SUCCESSFUL:  ${expected_dd}"
				return ${dont_overwrite_status}
			    fi
			    ;;
		    esac
		else
		    break
		fi
	    done  <<< $(split_n_vr_combinations ${pkg})

	    mkdir -p ${ddir}/sources
	    mkdir -p ${ddir}/_expand
	    local tmpdir=$(mktemp --tmpdir=${ddir}/_expand -d --suffix=srpmix7-$c--${distro})
	    local container_name=${${pkg/:/__}/+/__}
	    # Jan 14 18:18:53 srpmix7.localhost srpmix7[17460]: Error: error running container create option: names must match [a-zA-Z0-9][a-zA-Z0-9_.-]*: invalid argument
	    # Jan 14 18:18:53 srpmix7.localhost root[1703]: srpmix7 expanding dvd+rw-tools-7.1-15.el7 of rhel7...error: /home/srpmix7/_errors/tmp.IJYz4HlAPGsrpmix7-podman-srpm-expand--rhel7__dvd+rw-tools-7.1-15.el7
	    {
		podman run --name=${container_name}--${distro} --rm --volume ${tmpdir}:/out:z  srpmix7-"${distro}" \
		       srpmix7 expand --use-var-tmp --hookdir=/hooks --stype=${stype} --sloc=$pkg --dtype=dir --dloc=/out ${expander}

		podman_publish_maybe "${overwrite_even_if_incomplete}" ${ddir} ${tmpdir} ${expander} ${distro} ${pkg}
		local s=$?
	    }
	    return $s
	} >> $msgout
    } always {
	if [[ -n "${xargs}" ]]; then
	    logger --file "${msgout}"
	    rm "${msgout}"
	fi
    }
}

podman_has_image()
{
    podman image inspect srpmix7-"$1" > /dev/null 2>&1
}

podman_publish_maybe()
{
    local overwrite_even_if_incomplete=$1
    local destdir=$2
    local tmp_srcdir=$3
    local expander=$4
    local distro=$5
    local pkg=$6
    local msg
    local r

    if [[ -f "${tmp_srcdir}/${p_successful}" ]]; then
	msg=successful
	r=0
    elif [[ -f "${tmp_srcdir}/${p_incomplete}" ]]; then
	msg=incomplete
	r=1
    else
	local derror=${destdir}/_errors
	local derrortail=$(basename ${tmp_srcdir})__${pkg}
	mkdir -p "${derror}"
	mv "${tmp_srcdir}" "${derror}/${derrortail}"
	echo "error: ${derror}/${derrortail}"
	return 2
    fi

    local name=$(cat "${tmp_srcdir}/${p_info}"/srpm_query_NAME)
    local ver=$(cat "${tmp_srcdir}/${p_info}"/srpm_query_VERSION)
    local rel=$(cat "${tmp_srcdir}/${p_info}"/srpm_query_RELEASE)
    local epoch=$(cat "${tmp_srcdir}/${p_info}"/srpm_query_EPOCH)

    local n=$(name_prefix "${name}")
    local dtail

    if [[ -n "${epoch}" ]]; then
	dtail=${epoch}:${ver}-${rel}--${expander}
    else
	dtail=${ver}-${rel}--${expander}
    fi

    local d=${destdir}/sources/${n}/${name}
    local dd=${d}/${dtail}
    local dd_hiden=${d}/.${dtail}--$$

    if [[ -e "${dd}/${p_successful}" \
	      && "${msg}" == "incomplete" \
	      && ! ( -n "${overwrite_even_if_incomplete}" ) ]]; then
	echo "${msg} but existing as SUCCESSFUL: ${dd}"
	return $r
    fi

    local d_distro=${p_info}/podman-srpm-distro.d
    mkdir -p $d
    if [[ -e "${dd}" ]]; then
	mv "${dd}" "${dd_hiden}"
    fi

    mv ${tmp_srcdir} $dd
    chmod a+rx $dd
    if [[ -e "${dd_hiden}/${d_distro}" ]]; then
	mv "${dd_hiden}/${d_distro}" "${dd}/${d_distro}"
    fi

    mkdir -p "${dd}/${d_distro}"
    touch "${dd}/${d_distro}/${distro}"
    echo "${msg}: ${dd}"

    if [[ -e "${dd_hiden}" ]]; then
	rm -rf "${dd_hiden}"
    fi
    return $r
}

#
#
# Subcommand: podman-srpm-deploy
#
#
ICMD+=podman-srpm-deploy
ICMD_DESC[podman-srpm-deploy]="deploy source code in distros"

i_podman-srpm-deploy_help()
{
    =printf "%s\\\\\n" "$SELF podman-srpm-deploy [OPTIONS] DISTRO..."
    echo "OPTIONS:"
    {
	echo "	--output-directory|-o DIR"
	echo "		default: /var/lib/srpmix7"
	echo "	--procs|-n N"
	echo "		default: $(expr 3 \* $(nproc --ignore=1))"
	echo "	--dont-rebuild-image|-B"
	echo "	--dont-overwrite ..."
	echo "		see also: $SELF podman-srpm-expand --help"
    }
}

i_podman-srpm-deploy_run()
{
    local c=${${0#i_}%_run}
    local opt
    local next
    local odir=/var/lib/srpmix7
    local procs=$(expr 3 \* $(nproc --ignore=1))
    local dont_rebuild_image
    local dont_overwrite_option

    while [[ $# -gt 0 ]]; do
	case "$1" in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--output-directory|-o)
		if [[ -z "$2" ]]; then
		    -E- "$c: no directory name is given for $1 option"
		fi
		odir=$2
		shift 2
		;;
	    (--procs|-n)
		if [[ ! ("$2" =~ '[0-9]+') ]]; then
		    -E- "$c: a number expected for $1 option"
		fi
		if [[ $2 -eq 0 ]]; then
		    -E- "$c: nothing can be done without cpu"
		fi

		procs=$2
		shift 2
		;;
	    (--dont-rebuild-image|-B)
		dont_rebuild_image=1
		shift 1
		;;
	    (--dont-overwrite)
		dont_overwrite_option="--dont-overwrite=$2"
		shift 2
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    mkdir -p "${odir}"
    if [[ ! -d ${odir} ]]; then
	-E- "$c: no output directory"
    fi

    if [[ $# -eq 0 ]]; then
	-E- "$c: no distribution is given"
    fi

    local distro

    if [[ -z "${dont_rebuild_image}" ]]; then
	for distro in "$@"; do
	    i_podman-image-build_run "${distro}"
	    if ! podman_has_image ${distro}; then
		-E- "$c: error in building image for ${distro}"
	    fi
	done
    fi

    for distro in "$@"; do
	if ! podman_has_image ${distro}; then
	    -E- "$c: no image for ${distro}"
	fi
    done

    ${SELF_FULL} podman-srpm-pkglist --expand-args="${odir}" "$@" \
	| xargs --process-slot-var=CPUID \
		-P "${procs}" \
		-n 3 \
		${SELF_FULL} podman-srpm-expand --xargs=CPUID ${dont_overwrite_option}
}

#
#
# Subcommand: expand
#
#
ICMD+=expand
ICMD_DESC[expand]="expand source code"

typeset -A EXPAND_STYPE
typeset -A EXPAND_DTYPE
typeset -A EXPANDER

i_expand_help()
{
    local k

    =printf "%s\\\\\n" "$SELF expand [OPTIONS] "
    {
	=printf "  %s \\\\\n" "--stype=STYPE --sloc=SLOCATION"
	=printf "  %s \\\\\n" "--dtype=DTYPE --dloc=DLOCATION"
	=printf "  EXPANDER [EXPANDER-OPTION]..."
	echo
    } | indent
    echo "OPTIONS:"
    {
	echo "	--action-when-error=abort|continue*"
	echo "	--bundle"
	echo "	--debug"
	echo "	--quit-after=optparse|prepare"
	echo "	--trace"
	echo "	--help-expander=EXPANDER"
	echo "	--help-stype=STYPE"
	echo "	--help-dtype=DTYPE"
	echo "  --use-var-tmp"
	echo "	--hookdir=DIR"
    }
    echo "STYPE:"
    for k in ${(k)EXPAND_STYPE}; do
	=printf "%-10s	%s\n" "$k" "${EXPAND_STYPE[$k]}" | indent
    done

    echo "DTYPE:"
    for k in ${(k)EXPAND_DTYPE}; do
	=printf "%-10s	%s\n" $k "${EXPAND_DTYPE[$k]}" | indent
    done

    echo "EXPANDER:"
    for k in ${(k)EXPANDER}; do
	=printf "%-10s	%s\n" $k "${EXPANDER[$k]}" | indent
    done

}

#
# TODO:
#                    stype: apt-get,rsync
#                 expander: deb
# other interesting things: npm, cpan, pypi,
#
# npm view jstags dist.tarball > /dev/null => url: vanilla
#

#
# Return value
# 0: successful
# 1: error before expanding (critical error)
# 2: error in expanding
# 3: error after expanding
#
# If the return value is 3, it must be recorded somewhere other place.
i_expand_run()
{
    local -a args
    args=( "$@" )
    local c=${${0#i_}%_run}
    local opt
    local next
    local action_when_error=continue

    local src
    local stype
    local sloc
    local -a slocs_local
    local -r stype_default=file

    local dest
    local dtype
    local dloc
    local -r dtype_default=dir

    local expander
    local expander_default=srpm

    local bundle

    local checker

    local hookdir
    local hookarg

    local debug
    local quit_after

    local t
    local s
    local r

    local tmp_root=${TMPDIR:-/tmp}

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--help-expander|--help-stype|--help-dtype)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		fi
		x_help_${opt#--help-} $2
		return 0
		;;
	    (--action-when-error)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		else
		    case $2 in
			(abort|continue) action_when_error=$2;;
			(*) -E- "$c: unexpected value for $opt: $2";;
		    esac
		fi
		shift 2
		;;
	    (--bundle)
		bundle=1
		shift 1
		;;
	    (--debug|-d)
		debug=yes
		shift
		;;
	    (--dtype)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${dtype}" ]]; then
		    if [[ ${dtype} != $2 ]]; then
			-E- "$c: dtype is already given as ${dtype}: ${opt}=$2"
		    else
			dtype=$2
		    fi
		else
		    dtype=$2
		fi
		shift 2
		if ! member "$dtype" ${(k)EXPAND_DTYPE}; then
		    -E- "$c: no such dest type: $dtype"
		fi
		;;
	    (--dloc)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${dloc}" ]]; then
		    -E- "$c: dloc is already given as ${dloc}: ${opt}=$2"
		else
		    dloc=$2
		    shift 2
		fi
		;;
	    (--stype)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${stype}" ]]; then
		    if [[ ${stype} != $2 ]]; then
			-E- "$c: stype is already given as ${stype}: ${opt}=$2"
		    else
			stype=$2
		    fi
		else
		    stype=$2
		fi
		shift 2
		if ! member "$stype" ${(k)EXPAND_STYPE}; then
		    -E- "$c: no such src type: $stype"
		fi
		;;
	    (--sloc)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${sloc}" ]]; then
		    -E- "$c: sloc is already given as ${sloc}: ${opt}=$2"
		else
		    sloc=$2
		    shift 2
		fi
		;;
	    (--hookdir)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif ! [[ -d "$2" ]]; then
		    -E- "$c: hookdir doesn't exist: $2"
		else
		    hookdir=$2
		    shift 2
		fi
		;;
	    (--quit-after)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		else
		    case "$2" in
			(optparse|prepare) quit_after=$2;;
			(*) -E- "$c: unexpected value for $opt: $2" ;;
		    esac
		fi
		shift 2
		;;
	    (--trace|-x)
		set -x
		shift
		;;
	    (--use-var-tmp)
		tmp_root=/var/tmp
		shift
		;;
	    (--*)
		: ${expander:=${expander_default}}
		break
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		expander=$1
		shift
		if ! member "$expander" ${(k)EXPANDER}; then
		    -E- "$c: unknown expander: $expander"
		fi
		break
		;;
	esac
    done

    if [[ -z "$sloc" ]]; then
	-E- "$c: no SLOC is given"
    fi
    if [[ -z "$stype" ]]; then
	stype=${stype_default}
    fi

    check_requirements stype ${stype}
    checker="x_src_${stype}_precheck"
    if is_available $checker; then
	$checker "$sloc"
    fi

    if [[ -z "$dtype" && -z "$dloc" ]]; then
	dtype=${dtype_default}
	dloc=.
    elif [[ -z "$dtype" ]]; then
	dtype=${dtype_default}
    elif [[ -z "$dloc" ]]; then
	if [[ "$dtype" == "dir" ]]; then
	    dloc=.
	else
	    -E- "$c: no DLOC is given"
	fi
    fi
    checker="x_dest_${dtype}_check"
    check_requirements dtype ${dtype}
    if is_available $checker; then
	"$checker" "$dloc"
    fi

    #
    # TODO: convert to per backend funcs.
    #
    if [[ -z "$expander" ]]; then
	case "$stype" in
	    (yds|dds)
		expander_default=srpm
		;;
	    (yd)
		expander_default=brpm
		;;
	    (npm)
		expander_default=vanilla
		;;
	    (apts)
		expander_default=deb
		;;
	    (file|wget)
		case "$sloc" in
		    (*.src.rpm)
			expander_default=srpm
			;;
		    (*.rpm)
			expander_default=brpm
			;;
		    (*.lcopy)
			expander_default=lcopy
			;;
		    (*.zip|*.gz|*.bz2|*.xz)
			expander_default=vanilla
			;;
		esac
		;;
	esac
	expander=${expander_default}
    fi
    if [[ -z "$expander" ]]; then
	-E- "$c: no EXPANDER is given"
    fi

    checker="x_expand_${expander}_check"
    check_requirements expander ${expander}
    if is_available "$checker"; then
	"$checker"
    fi

    if [[ "${debug}" == "yes" ]]; then
	echo stype: $stype
	echo sloc: $sloc
	echo dtype: $dtype
	echo dloc: $dloc
	echo expander: $expander
    fi

    if [[ "$quit_after" == "optparse" ]]; then
	exit 0
    fi

    #
    # TODO: check the status of $dloc
    #       if not expanded yet, lock the directory.
    #
    {
	if ! t=$(mktemp --tmpdir="${tmp_root}" --directory ${SELF}-EXPAND-${expander}.XXXXXXXXXX) ; then
	    throw Creation
	elif [[ "${debug}" == "yes" ]]; then
	    echo tmpdir: $t
	fi

	if ! x_prepare $t; then
	    throw Preparation
	else
	    {
		: &&
		    echo "${c_version}" > $t/$p_uname/x_version &&
		    echo "${expander}"  > $t/$p_uname/expander  &&
		    echo "${args[@]}"   > $t/$p_uname/x_args    &&
		    echo "${stype}"     > $t/$p_uname/x_stype   &&
		    echo "${sloc}" > $t/$p_uname/x_sloc &&
		    echo "${dtype}"     > $t/$p_uname/x_dtype &&
		    echo "${dloc}" > $t/$p_uname/x_dloc
	    } || throw Preparation
	fi
	if [[ "$quit_after" == "prepare" ]]; then
	    exit 0
	fi

	hookarg=
	if x_use_stype_hook_p ${stype}; then
	    hookarg="--hookdir=$hookdir"
	fi
	if x_src_${stype}_transfer ${sloc} $t $hookarg; then
	    slocs_local=( $t/$p_stmp/*(N) )
	    echo "${slocs_local[@]}" > $t/$p_uname/x_slocs_local || throw Preparation
	    if [[ $#slocs_local == 0 ]]; then
		throw STransfer
	    fi
	else
	    throw STransfer
	fi

	hookarg=
	if x_use_expander_hook_p ${expander}; then
	    hookarg="--hookdir=$hookdir"
	fi
	if [[ $#slocs_local == 1 ]]; then
	    # Passing a file under the temporary directory.
	    checker="x_src_${stype}_postcheck"
	    if is_available $checker; then
		$checker "${slocs_local[1]}"
	    fi
	    x_expand_${expander}_run "${slocs_local[1]}" "$t" $hookarg "$@"
	elif [[ ${stype} == yds || ${stype} == dds ]]; then
	    #
	    # In rhel7 one yumdownloader invocation downloads two src.rpm files:
	    #
	    # [root@6a854e92b2d9 tmp]# yumdownloader --source shim-0.7-8.el7_0
	    # Loaded plugins: ovl, product-id, subscription-manager
	    # Enabling ubi-server-rhscl-7-source-rpms repository
	    # Enabling ubi-7-server-optional-source-rpms repository
	    # Enabling ubi-7-rhah-source repository
	    # Enabling ubi-7-server-extras-source-rpms repository
	    # Enabling ubi-7-server-devtools-source-rpms repository
	    # Enabling rhel-7-server-htb-source-rpms repository
	    # (1/2): shim-0.7-8.el7_0.src.rpm        | 1.1 MB  00:00:00
	    # (2/2): shim-signed-0.7-8.el7_0.src.rpm | 406 kB  00:00:00
	    #
	    # We have to choose proper one from them.
	    #
	    local sloc_candidate
	    local found_proper_sloc
	    for sloc_candidate in "${slocs_local[@]}"; do
		if [[ $(basename "${sloc_candidate}") == "${sloc}.src.rpm" ]]; then
		    found_proper_sloc=1
		    x_expand_${expander}_run "${sloc_candidate}" "$t" $hookarg "$@"
		    s=$?
		    break
		fi
	    done
	    if [[ -z "${found_proper_sloc}" ]]; then
		for sloc_candidate in "${slocs_local[@]}"; do
		    if [[ $(basename "${sloc_candidate}") =~ "${sloc}"'-[0-9].*\.src\.'rpm ]]; then
			found_proper_sloc=1
			x_expand_${expander}_run "${sloc_candidate}" "$t" $hookarg "$@"
			s=$?
			break
		    fi
		done
	    fi
	    if [[ -z "${found_proper_sloc}" ]]; then
		throw STransferMultiple
	    fi
	else
	    # Passing the temporary directory
	    x_expand_${expander}_run  $t/$p_stmp "$t" $hookarg "$@"
	    s=$?
	fi
    } always {
	local delayed_emsg

	if catch Creation; then
	    r=1
	    if [[ "$action_when_error" == continue ]]; then
		echo "$s_bug" "(failed to create working directory for expanding)\n" > $t/.$p_status
		ln -f -s -r $t/$p_status $t/$p_bug
	    else
		delayed_emsg="$c: failed to create working directory for expanding"
	    fi
	elif catch Prepare; then
	    r=1
	    if [[ "$action_when_error" == continue ]]; then
		echo "$s_bug" "(failed to prepare a directory for expansion)\n" > $t/.$p_status
		ln -f -s -r $t/$p_status $t/$p_bug
	    else
		delayed_emsg="$c: failed to prepare a directory for expansion"
	    fi
	elif catch STransferMultiple; then
	    r=1
	    if [[ "$action_when_error" == continue ]]; then
		echo "$s_bug" "(transfer multiple files from $sloc to $t by $stype)\n" > $t/.$p_status
		    ln -f -s -r $t/$p_status $t/$p_bug
		else
		    delayed_emsg="$c: transfer multiple files from $sloc to $t by $stype"
		fi
	else

	    if catch STransfer; then
		r=1
		if [[ "$action_when_error" == continue ]]; then
		    echo "$s_bug" "(failed to transfer data source from $sloc to $t by $stype)\n" > $t/.$p_status
		    ln -f -s -r $t/$p_status $t/$p_bug
		else
		    delayed_emsg="$c: failed to transfer data source from $sloc to $t by $stype"
		fi
	    elif [[ "$s" == 0 ]]; then
		r=0
		echo $s_successful > $t/.$p_status
		ln -f -s -r $t/$p_status $t/$p_successful
	    else
		if [[ ! -e $t/$p_incomplete ]]; then
		    ln -f -s -r $t/$p_status $t/$p_incomplete
		fi
		r=2
	    fi
	    if [[ "$s" == 0 || "$action_when_error" == continue ]]; then
		if x_dest_${dtype}_transfer "$t" "$dloc"; then
		    x_dest_${dtype}_commit "$dloc"
		    if [[ -n "$bundle" ]]; then
			attach_bundles $dloc
		    fi
		else
		    delayed_emsg="$c: failed to transfer expanded data to $dtype:$dloc from $t"
		    r=3
		fi
	    fi
	fi

	if [[ "${debug}" != "yes" ]]; then
	    rm -rf "$t"
	fi

	if [[ -n "${delayed_emsg}" ]]; then
	    -E- "${delayed_emsg}"
	fi
    }

    return $r
}

x_help_expander()
{
    local expander=$1
    local c

    if [[ -z "${EXPANDER[${expander}]}" ]]; then
	-E- "no such expander: ${expander}"
    fi

    x_expand_${expander}_help
    echo "Requirements:"
    for c in ${REQUIREMENTS[expander_${expander}]}; do
	echo "	$c"
    done
}

x_help_stype()
{
    local stype=$1
    local c

    if [[ -z "${EXPAND_STYPE[${stype}]}" ]]; then
	-E- "no such stype: ${stype}"
    fi

    x_src_${stype}_help
    echo "Requirements:"
    for c in ${REQUIREMENTS[stype_${stype}]}; do
	echo "	$c"
    done
}

x_help_dtype()
{
    local dtype=$1
    local c

    if [[ -z "${EXPAND_DTYPE[${dtype}]}" ]]; then
	-E- "no such dtype: ${dtype}"
    fi

    x_dest_${dtype}_help
    echo "Requirements:"
    for c in ${REQUIREMENTS[dtype_${dtype}]}; do
	echo "	$c"
    done
}

x_use_stype_hook_p()
{
    use_hook_p stype_$1
}

x_use_expander_hook_p()
{
    use_hook_p expander_$1
}

x_run_hook_maybe()
{
    local type_prefix=$1
    shift 1

    local hookdir=$1

    if [[ -z "$hookdir" ]]; then
	return 0
    fi

    local type="${type_prefix}_$2"
    local hook=$3
    shift 3

    run_hook "$hookdir" "$type" "$hook" "$@"
}

x_run_stype_hook_maybe()
{
    x_run_hook_maybe stype "$@"
}

x_run_expander_hook_maybe()
{
    x_run_hook_maybe expander "$@"
}

#
# TODO: Allow symlink from pre-build to archive
#
x_prepare()
{
    local d=$1
    local elt

    for elt in $p_archives $p_pre_build $p_info $p_bundles $p_uname $p_log $p_xtmp $p_stmp; do
	if ! mkdir ${d}/${elt}; then
	    return 1
	fi
    done

    elt=.$p_status
    echo "${s_unknown}" > ${d}/${elt}

    return 0
}


#
# STYPES
#
EXPAND_STYPE[apts]="a file downloaded by apt-get source"
REQUIREMENTS[stype_apts]="apt-get"
x_src_apts_help()
{
    echo "Usage:"
    echo "	... expand --stype=apts --sloc=NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=apts --sloc=postfix --dtype=dir --dloc=/tmp deb"
}

x_src_apts_postcheck()
{
    local sloc=$1

    if [[ ! -e "$sloc" ]]; then
	-T- STransfer "$c: no such dentry: $sloc"
    elif [[ ! -d "$sloc" ]]; then
	-T- STransfer "$c: no such directory: $sloc"
    elif [[ ! -r "$sloc" ]]; then
	-T- STransfer "$c: dir unreadable: $sloc"
    elif [[ ! -x "$sloc" ]]; then
	-T- STransfer "$c: dir untraversable: $sloc"
    fi

    local -a dsc
    dsc=( $sloc/*.dsc(N) )
    if [[ ${#dsc} == 0 ]]; then
	-T- STransfer "$c: no dsc file found in $sloc"
    elif [[ ${#dsc} -gt 1 ]]; then
	-T- STransfer "$c: more than one dsc files are found in $sloc"
    elif [[ ! -e "${dsc[1]}" ]]; then
	-T- STransfer "$c: no such dentry: ${dsc[1]}"
    elif [[ ! -f "${dsc[1]}" ]]; then
	-T- STransfer "$c: no such file: ${dsc[1]}"
    elif [[ ! -r "${dsc[1]}" ]]; then
	-T- STransfer "$c: file not readable: ${dsc[1]}"
    fi

    return 0
}

x_src_apts_transfer()
{
    local name=$1
    local t=$2
    local s

    (
	cd $t/$p_stmp;
	apt-get source --download-only $name
	exit $? ) > $t/$p_log/x_s_apt-source-transfer.log 2>&1
    s=$?
    echo $s > $t/$p_log/x_s_apt-source-transfer.status
    return $s
}

EXPAND_STYPE[npm]="node package"
REQUIREMENTS[stype_npm]="npm"
x_src_npm_help()
{
    echo "Usage:"
    echo "	... expand --stype=npm --sloc=NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=npm --sloc=uniator --dtype=dir --dloc=/tmp vanilla"
}

x_src_npm_transfer()
{
    local name=$1
    local t=$2
    local url
    local s

    url=$(npm view ${name} dist.tarball 2> $t/$p_log/x_s_npm-view-dist-tarball.log)
    s=$?
    echo "$s $url" >> $t/$p_log/x_s_npm-view-dist-tarball.log

    if [[ "${s}" != 0 ]]; then
	return $s
    elif [[ -z "$url" ]]; then
	echo "npm: returned URL is empty" >> $t/$p_log/x_s_npm-view-dist-tarball.log
	return 1
    fi

    x_src_wget_transfer "$url" $t
    return $?
}

EXPAND_STYPE[file]="regular file"
REQUIREMENTS[stype_file]=""

x_src_file_help()
{
    echo "Usage:"
    echo "	... expand --stype=file --sloc=FILE ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=file --sloc=/tmp/coreutils-8.22-11.el7.src.rpm --dtype=dir --dloc=/tmp srpm"
}
x_src_file_precheck()
{
    local sloc=$1

    if [[ ! -e "$sloc" ]]; then
	-E- "$c: no such file: $sloc"
    elif [[ ! -r "$sloc" ]]; then
	-E- "$c: file unreadable: $sloc"
    fi
}

x_src_file_postcheck()
{
    local sloc=$1

    if [[ ! -e "$sloc" ]]; then
	-T- STransfer "$c: no such file: $sloc"
    elif [[ ! -r "$sloc" ]]; then
	-T- STransfer "$c: file unreadable: $sloc"
    fi
}

x_src_file_transfer()
{
    local sloc=$1
    local t=$2

    local abs_sloc
    local s


    ln $sloc $t/$p_stmp/${sloc:t} > $t/$p_log/x_s_file-ln-transfer.log 2>&1
    s=$?
    echo $s > $t/$p_log/x_s_file-ln-transfer.status

    if [[ "${sloc[1]}" == '/' ]]; then
	abs_sloc=${sloc}
    else
	abs_sloc=$(pwd)/$sloc
    fi

    if [[ $s != 0 ]]; then
	( cd $t/$p_stmp && cp -s $abs_sloc ./${sloc:t} ) > $t/$p_log/x_s_file-cp-transfer.log 2>&1
	s=$?
	echo $s > $t/$p_log/x_s_file-cp-transfer.status
    fi

    return $s
}

EXPAND_STYPE[wget]="something specified with URL"
REQUIREMENTS[stype_wget]="wget"
x_src_wget_help()
{
    echo "Usage:"
    echo "	... expand --stype=wget --sloc=URL ..."
}
x_src_wget_transfer()
{
    local sloc=$1
    local t=$2
    local s

    ( cd $t/$p_stmp;
      wget $sloc;
      exit $? ) > $t/$p_log/x_s_wget-transfer.log 2>&1

    s=$?
    echo $s > $t/$p_log/x_s_wget-transfer.status
    return $s
}

EXPAND_STYPE[git]="git repository"
REQUIREMENTS[stype_git]=""
x_src_git_help()
{
    echo "Usage:"
    echo "	... expand --stype=git --sloc=http://... ..."
    echo "	... expand --stype=git --sloc=https://... ..."
    echo "	... expand --stype=git --sloc=git://... ..."
    echo "	... expand --stype=git --sloc=[http://...]branch ..."
    echo "	... expand --stype=git --sloc=[https://...]branch ..."
    echo "	... expand --stype=git --sloc=[git://...]branch ..."
}
x_src_git_precheck()
{
    local sloc=$1

    if  ! [[ ( "$sloc" =~ "^(http|https|git)://.*" )
	|| ( "$sloc" =~ "^\[(HTTP|https|git)://.*\].*" ) ]]; then
	-E- "$c: unexpected git repo URL: $sloc"
    else
	return 0
    fi
}
x_src_git_postcheck()
{
    x_src_file_postcheck $1
}

x_src_git_transfer()
{
    local sloc=$1
    local t=$2
    local s

    local repo
    local branch

    case "$sloc" in
	(\[*\]*)
	    repo=${${sloc%\]*}[2,-1]}
	    branch=${sloc#\[*\]}

	    if [[ -z "${repo}" ]]; then

	    fi
	    lcopy_genconf git "$repo" --branch "$branch"
	    ;;
	(*)
	    lcopy_genconf git "$sloc"
	    ;;
    esac  > ${t}/$p_stmp/_.lcopy 2> $t/$p_log/x_s_git-transfer.log

    s=$?
    echo $s > $t/$p_log/x_s_git-transfer.status
    return $s
}

EXPAND_STYPE[dds]="a file downloaded by dnf download --source"
REQUIREMENTS[stype_dds]="dnf"
USE_HOOK[stype_dds]="before-download after-download"

x_src_dds_help()
{
    echo "Usage:"
    echo "	... expand --stype=dds --sloc=\[REPO\]NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=dds --sloc=[rhel-7-server-source-rpms]coreutils --dtype=dir --dloc=/tmp srpm"
    echo "	srpmix7 expand --stype=dds --sloc=coreutils --dtype=dir --dloc=/tmp srpm"
    echo "	srpmix7 expand --stype=dds --sloc=coreutils-8.22-11.el7 --dtype=dir --dloc=/tmp srpm"

    print_available_hooks stype_dds
}

x_src_dds_precheck()
{
    :
}

x_src_dds_postcheck()
{
    x_src_file_postcheck $1
}

x_src_dds_transfer()
{
    local sloc=$1
    local t=$2
    shift 2

    local pname
    local repo
    local s

    local hookdir
    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--hookdir=*)
		hookdir=${1#*=}
		shift 1
		;;
	    (*)
		-E- "unexpectd argument for srpm expander: $1"
		;;
	esac
    done

    {
	x_run_stype_hook_maybe "$hookdir" dds before-download
	case "$sloc" in
	    (\[*\]*)
		pname=${sloc#\[*\]}
		repo=${${sloc%\]*}[2,-1]}
		if [[ -z "$hookdir" ]]; then
		    dnf download --source --downloaddir ${t}/$p_stmp --disablerepo '*' --enablerepo "$repo" $pname
		else
		    dnf download --source --downloaddir ${t}/$p_stmp --enablerepo "$repo" $pname
		fi
		s=$?
		;;
	    (*)
		dnf download --source --downloaddir ${t}/$p_stmp $sloc
		s=$?
		;;
	esac
	x_run_stype_hook_maybe "$hookdir" dds after-download
    } > $t/$p_log/x_s_dds-transfer.log 2>&1
    echo $s > $t/$p_log/x_s_dds-transfer.status
    return $s
}

EXPAND_STYPE[yds]="a file downloaded by yumdownloader --source"
REQUIREMENTS[stype_yds]="yumdownloader"
USE_HOOK[stype_yds]="before-download after-download"
x_src_yds_help()
{
    echo "Usage:"
    echo "	... expand --stype=yds --sloc=\[REPO\]NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=yds --sloc=[rhel-7-server-source-rpms]coreutils --dtype=dir --dloc=/tmp srpm"
    echo "	srpmix7 expand --stype=yds --sloc=coreutils --dtype=dir --dloc=/tmp srpm"
    echo "	srpmix7 expand --stype=yds --sloc=coreutils-8.22-11.el7 --dtype=dir --dloc=/tmp srpm"

    print_available_hooks stype_yds
}

x_src_yds_precheck()
{
    :
}

x_src_yds_postcheck()
{
    x_src_file_postcheck $1
}

x_src_yds_transfer()
{
    local sloc=$1
    local t=$2
    shift 2

    local pname
    local repo
    local s

    local hookdir
    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--hookdir=*)
		hookdir=${1#*=}
		shift 1
		;;
	    (*)
		-E- "unexpectd argument for srpm expander: $1"
		;;
	esac
    done

    {
	x_run_stype_hook_maybe "$hookdir" yds before-download
	case "$sloc" in
	    (\[*\]*)
		pname=${sloc#\[*\]}
		repo=${${sloc%\]*}[2,-1]}
		if [[ -z "$hookdir" ]]; then
		    yumdownloader --source --destdir ${t}/$p_stmp --disablerepo '*' --enablerepo "$repo" $pname
		else
		    yumdownloader --source --destdir ${t}/$p_stmp --enablerepo "$repo" $pname
		fi
		s=$?
		;;
	    (*)
		yumdownloader --source --destdir ${t}/$p_stmp $sloc
		s=$?
		;;
	esac
	x_run_stype_hook_maybe "$hookdir" yds after-download
    } > $t/$p_log/x_s_yds-transfer.log 2>&1
    echo $s > $t/$p_log/x_s_yds-transfer.status
    return $s
}

EXPAND_STYPE[yd]="a file downloaded by yumdownloader (no --source)"
REQUIREMENTS[stype_yd]="yumdownloader"
x_src_yd_help()
{
    echo "Usage:"
    echo "	... expand --stype=yd --sloc=\[REPO\]NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=yd --sloc=[rhel-7-server-source-rpms]coreutils --dtype=dir --dloc=/tmp brpm"
    echo "	srpmix7 expand --stype=yd --sloc=coreutils --dtype=dir --dloc=/tmp brpm"
    echo "	srpmix7 expand --stype=yd --sloc=coreutils-8.22-11.el7 --dtype=dir --dloc=/tmp brpm"
}

x_src_yd_precheck()
{
    :
}

x_src_yd_postcheck()
{
    x_src_file_postcheck $1
}

x_src_yd_transfer()
{
    local sloc=$1
    local t=$2
    local pname
    local repo
    local s

    case "$sloc" in
	(\[*\]*)
	    pname=${sloc#\[*\]}
	    repo=${${sloc%\]*}[2,-1]}
	    yumdownloader --destdir ${t}/$p_stmp --disablerepo '*' --enablerepo "$repo" $pname
	    ;;
	(*)
	    yumdownloader --destdir ${t}/$p_stmp $sloc
	    ;;
    esac > $t/$p_log/x_s_yd-transfer.log 2>&1
    s=$?
    echo $s > $t/$p_log/x_s_yd-transfer.status
    return $s
}


#
# DTYPES
#
EXPAND_DTYPE[dir]="sources7 lower directory layout"
REQUIREMENTS[dtype_dir]="cp tar"
x_dest_dir_help()
{
    :
}

x_dest_dir_check()
{
    local dloc=$1

    if [[ ! -e "$dloc" ]]; then
	-E- "$c: no such directory: $dloc"
    elif [[ ! -d "$dloc" ]]; then
	-E- "$c: not directory: $dloc"
    elif [[ ! -w "$dloc" ]]; then
	-E- "$c: directory unwritable: $dloc"
    fi
}

x_dest_dir_transfer()
{
    local src=$1
    local dest=$2
    local s=0

    for x in ${src}/*(N) ${src}/._*(N); do
	if [[ "${x:t}" == __* ]]; then
	    # __tmp should not be transferred.
	    continue
	fi

	if [[ "${x:t}" == "${p_log}" && $(< ${src}/.${p_status}) == ${s_successful} ]]; then
	    # compress the log files only successful
	    if ! { (cd "${x:h}" && tar Jcf "${p_log}".tar.xz ./${p_log} ) \
		       && rm -rf ${x} && cp -r ${x}.tar.xz "${dest}" }; then
		s=1
		break
	    fi
	elif ! cp -r $x "${dest}"; then
	    # just copy
	    s=1
	    break
	fi
    done

    return $s
}

x_dest_dir_commit()
{
    local dest=$1
    local s=0

    mv ${dest}/.$p_status ${dest}/$p_status
    return $?
}

#
# EXPANDERS
#
EXPANDER[deb]="debian source package"
REQUIREMENTS[expander_deb]="dpkg-source"
x_expand_deb_help()
{
    :
}

x_expand_deb_run()
{
    local stmp=$1
    local t=$2
    shift 2

    local s

    local a
    local -a t_dsc
    local -a t_archives

    echo "$@"  > $t/$p_uname/x_deb_args

    t_dsc=${$(echo $stmp/*.dsc)[1]}
    t_archives=( $stmp/* )
    dpkg-source -x ${t_dsc} $t/$p_xtmp/${p_pre_build} > "$t/$p_log/x_deb-dpkg-source-x.log" 2>&1
    s=$?
    echo $s > "$t/$p_log/x_deb-dpkg-source-x.status"

    if [[ $s != 0 ]]; then
	printf "%s (failed in dpkg-source -x for %s)\n" $s_incomplete ${t_dsc:t} > $t/.$p_status
    else
	mv $t/$p_xtmp/${p_pre_build}/* $t/${p_pre_build}
	for a in ${t_archives[@]}; do
	    if [[ "${a}" == "${t_dsc}" ]]; then
		continue
	    fi
	    mv "$a" $t/$p_archives/
	done

	mv ${t_dsc} $t/$p_info/${t_dsc:t}

	make_all_readable "$t/$p_archives"
	make_file_unwritable "$t/$p_archives"
    fi

    make_all_readable "$t/$p_pre_build"
    make_file_unwritable "$t/$p_pre_build"

    return $s
}

x_expand_deb_check()
{
    :
}

EXPANDER[vanilla]="unarchivers frontend"
REQUIREMENTS[expander_vanilla]="tar unzip gunzip bunzip2 unxz"
x_expand_vanilla_help()
{
    :
}

x_expand_vanilla_run()
{
    local archive=$1
    local t=$2
    shift 2
    local s

    echo "$@"  > $t/$p_uname/x_vanilla_args

    vanilla $archive $t/$p_xtmp > "$t/$p_log/x_vanilla.log" 2>&1
    s=$?
    echo $s > "$t/$p_log/x_vanilla.status"

    if [[ -d "$t/$p_xtmp" ]] && ( ! is_empty_dir "$t/$p_xtmp" ); then
	mv $t/$p_xtmp/*	$t/$p_archives
    fi

    make_all_readable    "$t/$p_archives"
    make_file_unwritable "$t/$p_archives"


    return $s
}

x_expand_vanilla_check()
{
    :
}

EXPANDER[brpm]="binary rpm"
REQUIREMENTS[expander_brpm]="rpm2cpio cpio rpm"

x_expand_brpm_help()
{
    :
}

x_expand_brpm_run()
{
    local brpm=$1
    local t=$2
    shift 2

    local s

    echo "$@"  > $t/$p_uname/x_brpm_args

    echo "rpm2cpio" > $t/$p_uname/x_brpm_method
    for tag in $(rpm --nosignature --querytags); do
	rpm --nosignature -qp --queryformat '[%{'${tag}'}\n]' "${brpm}" \
	    > $t/$p_info/brpm_query_${tag//\//_/}
    done

    {
	rpm2cpio $brpm | (cd $t/$p_xtmp && cpio -dim) > "$t/$p_log/x_brpm-rpm2cpio--cpio-dim.log" 2>&1
	s=$?
	echo $s > "$t/$p_log/x_brpm-rpm2cpio-cpio-dim.status"
	if [[ $s != 0 ]]; then
	    throw RPM2CPIO__CPIO_DIM
	fi
    } always {
	if catch RPM2CPIO__CPIO_DIM; then
	    =printf "%s (failed in rpm2cpio or cpio -dim for %s)\n" $s_incomplete ${brpm:t} > $t/.$p_status
	fi

	if [[ -d "$t/$p_xtmp" ]] && ( ! is_empty_dir "$t/$p_xtmp" ); then
	    mv $t/$p_xtmp/*	$t/$p_archives
	fi
    }

    make_all_readable    "$t/$p_archives"
    make_file_unwritable "$t/$p_archives"

    return $s

}
x_expand_brpm_check()
{
    :
}

EXPANDER[srpm]="source rpm"
REQUIREMENTS[expander_srpm]="rpm rpmbuild"
USE_HOOK[expander_srpm]="before-builddep after-builddep"

x_expand_srpm_name_name()
{
    rpm --nosignature -qp --queryformat "%{NAME}\n" $1
}

x_expand_srpm_name_version()
{
    rpm --nosignature -qp --queryformat "%{VERSION}-%{RELEASE}\n" $1
}

x_expand_srpm_help()
{
    echo "Usage:"
    echo "	... expand ... srpm [--deps] [--nobuilddep]"

    print_available_hooks expander_srpm
}

x_expand_srpm_run()
{
    local srpm=$1
    local t=$2
    shift 2

    local nodeps=--nodeps
    local nobuilddep=
    local hookdir=

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--deps)
		nodeps=
		shift 1
		;;
	    (--nobuilddep)
		nobuilddep=1
		shift 1
		;;
	    (--hookdir=*)
		hookdir=${1#*=}
		shift 1
		;;
	    (*)
		-E- "unexpectd argument for srpm expander: $1"
		;;
	esac
    done

    local tag
    local -a t_spec
    local s

    rpm --version  > $t/$p_uname/x_srpm_rpm_command_version
    echo "$@"  > $t/$p_uname/x_srpm_args

    echo "install-build-pre" > $t/$p_uname/x_srpm_method
    #
    # TODO: Separate mock method and ibp method.
    #
    for tag in $(rpm --nosignature --querytags); do
	rpm --nosignature -qp --queryformat '[%{'${tag}'}\n]' "${srpm}" \
	    > $t/$p_info/srpm_query_${tag//\//_/}
    done

    if [[ -z "${nobuilddep}" ]]; then
	{
	    x_run_expander_hook_maybe "$hookdir" srpm before-builddep
	    if rpm -q dnf-plugins-core > /dev/null 2>&1; then
		dnf builddep -y --allowerasing --skip-broken --nobest "${srpm}"
		s=$?
	    elif rpm -q yum-utils > /dev/null 2>&1; then
		yum-builddep -y --skip-broken "${srpm}"
		s=$?
	    else
		echo "cannot find neither dnf-builddep nor yum-builddep"
		s=1
	    fi
	    echo $s > "$t/$p_log/x_srpm-builddep.status"
	    x_run_expander_hook_maybe "$hookdir" srpm after-builddep
	} > "$t/$p_log/x_srpm-builddep.log" 2>&1
    fi

    {
	rpm --nosignature --define="_topdir $t/$p_xtmp" -ivh "${srpm}" \
	    > "$t/$p_log/x_srpm-rpm-ivh.log" 2>&1
	s=$?
	echo $s > "$t/$p_log/x_srpm-rpm-ivh.status"
	if [[ $s != 0 ]]; then
	    throw RPM_I
	fi

	#
	# rhev-agent-2.3.16-3.el6.src.rpm contains gdm*.src.rpm as SOURCE1.
	# So two spec files, one for rhev-agent and one for gdm are in SPECS directory.
	# This becomes a trouble whev moving SPECS/*.spec  specs/srpm.spec.
	# So The spec file name is recorded to t_spec here. The spec file for
	# gdm generated while rpmbuild-bp is throws away when moving.
	#
	t_spec=( $t/$p_xtmp/SPECS/*.spec(N) )
	if [[ ${#t_spec} != 1 ]]; then
	    throw WRONG_SPEC_NUM
	fi

	rpmbuild --define="_topdir $t/$p_xtmp" ${nodeps} --target=x86_64 -bp ${t_spec[1]} \
		 > "$t/$p_log/x_srpm-rpmbuild-bp.log" 2>&1 \
		 < <(yes "")
	s=$?
	echo $s > "$t/$p_log/x_srpm-rpmbuild-bp.status"
	if [[ $s != 0 ]]; then
	    throw RPMBUILD_BP
	fi
    } always {
	if catch RPM_I; then
	    =printf "%s (failed in rpm -ivh %s)\n" $s_incomplete ${srpm:t} > $t/.$p_status
	elif catch WRONG_SPEC_NUM; then
	    =printf "%s (wrong number of spec file(s): ${#t_spec})\n" $s_incomplete > $t/.$p_status
	elif catch RPMBUILD_BP; then
	    =printf "%s (failed in rpmbuild -bp ${p_srpm_spec})\n" $s_incomplete > $t/.$p_status
	    ln -f -s -r $t/$p_log/x_srpm-rpmbuild-bp.log  $t/$p_incomplete
	fi

	if [[ -f "${t_spec[1]}" ]]; then
	    mv "${t_spec[1]}"   $t/$p_info/${t_spec[1]:t}
	    ln -r -s $t/$p_info/${t_spec[1]:t} $t/${p_srpm_spec}
	fi

	# TODO HANDLE ERRORS
	if [[ -d "$t/$p_xtmp/SOURCES" ]] && ( ! is_empty_dir "$t/$p_xtmp/SOURCES" ); then
	    make_all_readable    "$t/$p_xtmp/SOURCES"
	    mv $t/$p_xtmp/SOURCES/*      $t/$p_archives
	fi

	if [[ -d "$t/$p_xtmp/BUILD" ]] && ( ! is_empty_dir "$t/$p_xtmp/BUILD" ); then
	    make_all_readable    "$t/$p_xtmp/BUILD"
	    mv $t/$p_xtmp/BUILD/*     $t/$p_pre_build
	fi
    }

    if [[ -f "$t/$p_log/x_srpm-rpmbuild-bp.log" ]]; then
	x_expand_srpm_clean_patch_backup_files "$t/$p_pre_build" "$t/$p_log/x_srpm-rpmbuild-bp.log" \
					       > "$t/$p_log/x_srpm-clean-patch-backupfile.log"
    fi

    make_file_unwritable "$t/$p_archives"
    make_file_unwritable "$t/$p_pre_build"

    # x_expand_srpm_owner

    return $s
}

x_expand_srpm_clean_patch_backup_files()
{
    local target=$1
    local hint=$2

    local suffix
    local patched_file
    local backup_file
    local f
    while IFS= read -r; do
	if [[ "$REPLY" =~ '.*/patch[[:space:]]{1,}.*[[:space:]]{1,}--suffix[[:space:]]{1,}([^[:space:]]{1,}).*' ]]; then
	    suffix=${REPLY[${mbegin[1]}, ${mend[1]}]}
	elif [[ "$REPLY" =~ '.*/patch[[:space:]]{1,}.*[[:space:]]{1,}.*' ]]; then
	    # No --suffix option is given: use default suffix.
	    suffix=.orig
	elif [[ "$REPLY" =~ '^patching file (.{1,})$' ]]; then
	    patched_file=${REPLY[${mbegin[1]}, ${mend[1]}]}
	    if [[ -z "${suffix}" ]]; then
		continue
	    fi
	    backup_file=${patched_file}${suffix}

	    for f in ${target}/**/${backup_file}(N); do
		[[ -e $f ]] && rm "$f" && echo "${f#${target}/}"
	    done
	fi
    done < ${hint}
}

x_expand_srpm_check()
{
    :
}

EXPANDER[lcopy]="local copy"
REQUIREMENTS[expander_lcopy]="git"
x_expand_lcopy_help()
{
    :
}

x_expand_lcopy_run()
{
    # TODO: update
    local lcopy=$1
    local t=$2
    local s

    lcopy_checkout $lcopy $t/$p_xtmp > $t/$p_log/x_lcopy-checkout.log 2>&1
    s=$?
    echo $s > "$t/$p_log/x_lcopy-checkout.status"
    cp ${lcopy} $t/$p_info/_.lcopy
    if ! is_empty_dir "$t/$p_xtmp"; then
	mv $t/$p_xtmp/*      $t/$p_archives
    fi

    if [[ $s != 0 ]]; then
	=printf "%s (%s: %s)\n" $s_incomplete $(lcopy_describe_error $s) ${lcopy:t} \
	 > $t/.$p_status
    fi
    return $s
}

x_expand_lcopy_check()
{
    :
}


#
#
# Bundle
#
#

attach_bundles()
{
    local d=$1
    local b
    for b in ${(k)BUNDLES}; do
	subcommand_run bundle $d $b || :
    done
}

#
#
# MAIN
#
#

init()
{
    XCMD_DIR=${SRPMIX7_XCMD_DIR:-${EVAR_DEFAULT[XCMD_DIR]}}
    if [[ ! -d "${XCMD_DIR}" ]]; then
	if [[ "${XCMD_DIR}" == "${EVAR_DEFAULT[XCMD_DIR]}" ]]; then
	    #
	    # NO WARNING
	    #
	    :
	else
	    -E- "No such directory: SRPMIX7_XCMD_DIR=${XCMD_DIR}"
	fi
    elif ! XCMD_DIR=$(realpath -q "${XCMD_DIR}"); then
	-E- "Cannot resolve path: XCMD_DIR=${XCMD_DIR}"
    else
	SRPMIX7_XCMD_DIR=${XCMD_DIR}
    fi
}

help()
{
    local r=$1

    printf "Command usage:\n"
    =printf "	%-40s %s\n" "$SELF -h|--help"             "show this help message"
    =printf "	%-40s %s\n" "$SELF [OPTIONS] SUBCOMMAND" "run SUBCOMMAND"
    =printf "	%-40s %s\n" "$SELF help SUBCOMMAND"      "show help messages about SUBCOMMAND"

    echo
    printf "Options:\n"
    =printf "	%-20s %s\n" "-x|--trace"      "trace the execution"

    echo
    printf "Subcommands:\n"
    subcommand_enumerate -v | indent

    echo
    printf "Environment variables:\n"
    evar_enumerate -v | indent

    echo
    exit $r
}

run()
{
    local c
    local r

    if [[ $# -eq 0 ]]; then
	help 1 1>&2
    else
	case "$1" in
	    (-h|--help)
		help 0
		;;
	    (-x|--trace)
		set -x
		shift
		;;
	    (-*)
		-E%- "unknown option: %s\n" "$1"
		;;
	    (*)
		;;
	esac
    fi

    if ! subcommand_exist_p "$1"; then
	-E%- "unknown subcommand: %s\n" "$1"
    else
	c="$1"
	shift
    fi


    subcommand_run "$c" "$@"
    r=$?

    return $r
}

#
#
# LCOPY
#
#
readonly lcopy_cf_version=0.4
readonly lcopy_git_cf_version=0.0.1

readonly lcopy_error_wrong_syntax=1
readonly lcopy_error_undefined_value=2

typeset -a LCOPY_ERROR
LCOPY_ERROR=(
    "broken lcopy file (failed in source)"
    "expected value is not defined in lcopy file"
    "failed in checkout operation"
)

lcopy_describe_error()
{
    local msg=${LCOPY_ERROR[$1]}
    echo "lcopy: ${msg:-unknown error code: $1}"
}

lcopy_git_checkout()
{
    local input=$1
    local dir=$2
    local s

    (
	if source ${lcopy}; then
	    if [[ -z "${GIT_REPOSITORY}" ]]; then
		echo "no GIT_REPOSITORY in $input" 1>&2
		return ${lcopy_error_undefined_value}
	    fi

	    if [[ -z "${GIT_BRANCH}" ]]; then
		git clone --recursive "${GIT_REPOSITORY}" "${dir}"
	    else
		git clone --recursive --branch "${GIT_BRANCH}" "${GIT_REPOSITORY}" "${dir}"
	    fi
	    s=$?

	    if [[ $s != 0 ]]; then
		return ${lcopy_failed_in_checkout}
	    fi
	else
	    return ${lcopy_error_wrong_syntax}
	fi
    )
}

lcopy_checkout()
{
    local lcopy=$1
    local vcs

    if ! vcs=$( source "${lcopy}" && echo "$LCOPY_VCS" ); then
	return ${lcopy_error_wrong_syntax}
    elif [[ -z "${vcs}" ]]; then
	return ${lcopy_error_undefined_value}
    fi

    case "$vcs" in
	(git)
	    lcopy_${vcs}_checkout "$@"
	    ;;
	(*)
	    ;;
    esac
}

lcopy_git_genconf()
{
    local repo=$1
    shift

    local branch

    while [[ $# -gt 0 ]]; do
	case "$1" in
	    (--branch)
		branch=$2
		shift 2
		;;
	    (--*)
		-E- "lcopy: unknown option given: $@"
		;;
	    (*)
		-E- "lcopy: unexpected argument given: $@"
		;;
	esac
    done

    cat  <<EOF
# -*- shell-script -*-
GIT_CF_VERSION="${lcopy_git_cf_version}"
GIT_REPOSITORY="$repo"
EOF
    if [[ -n "${branch}" ]]; then
	cat <<EOF
GIT_BRANCH=${branch}
EOF
    fi

    cat <<EOF
LCOPY_CF_VERSION="${lcopy_cf_version}"
LCOPY_VCS="git"
LCOPY_UPDATE="yes"
LCOPY_GENERATED_BY=$SELF
EOF
    return 0
}

lcopy_genconf()
{
    local vcs=$1
    shift

    if [[ -z "$vcs" ]]; then
	-E-
    fi

    case "$vcs" in
	(git)
	    lcopy_${vcs}_genconf "$@"
	    ;;
	(*)
	    ;;
    esac
}


#
#
# VANILLA
#
#
vanilla()
{
    local archive=$1
    local output=$2
    local s

    (cd ${output};
     case "$archive" in
	 (*.zip)
	     unzip -o "$f"
	     s=$?
	     ;;
	 (*.tar.gz|*.tgz|*.tar.Z)
	     tar zxf "$archive"
	     s=$?
	     ;;
	 (*.tar.bz2|*.tbz|*.tbz2)
	     tar jxf "$archive"
	     s=$?
	     ;;
	 (*.tar.xz|*.txz)
	     tar Jxf "$archive"
	     s=$?
	     ;;
	 (*.gz|*.Z)
	     gunzip --keep --force --stdout "$archive" > ./"${archive:h:r}"
	     s=$?
	     ;;
	 (*.bz2)
	     bunzip2 --keep --force --stdout "$archive" > ./"${archive:h:r}"
	     s=$?
	     ;;
	 (*.xz)
	     unxz --keep --force --stdout "$archive"   > ./"${archive:h:r}"
	     s=$?
	     ;;
	 (*)
	     echo "vanilla: no handler for $archive" 2>&1
	     s=1
	     ;;
     esac
     exit $s
    )
    return $?
}

#
# pname
#
pname_name()
{
    local expander=$1
    local src=$2

    # TODO check
    x_expand_${expander}_name_name $2

}

pname_version()
{
    local expander=$1
    local src=$2

    # TODO check
    x_expand_${expander}_name_version $2
}


#
# file locking
#
lock()
{
    local v=$1
    integer -l r

    exec {r}< $2
    if flock --nonblock $r; then
	eval "$v"="$r"
	return 0
    else
	return 1
    fi
}

unlock()
{
    integer -l r=$1
    exec {r}>&-
}


init
run "$@"

#
# FILE/DIRECTORY LAYOUT SPECIFICATION
# ======================================================================
#
# The 7th raw directory specification
# ----------------------------------------------------------------------
# *archives* directory
#
#	the original data and patches
#
# *pre-build* directory/symlink
#
#	synthesized data for compiler
#       A symlink is used in the case nothing is synthesized.
#
# *specs* directory
#
#       Meta information about the source code.
#       The contents are upto an expander.
#       e.g. specs.spec in srpmix5 is renamed to
#            *specs*/srpm.spec.
#
#
# *_status* file
#
#       The result of expansion/synthesizing.
#
#       The file content is one of following.
#
#	`unknown`
#
#                 The expansion is failed too early stage to record the
#                 status. It implies the issue in th environment of expansion.
#
#	`successful`
#
#                 The expansion is successfully done. Expanded/synthesized
#                 source code are reliable to source code analysis/reading.
#
#	`error(REASON)`
#
#                 The expansion is failed in a stage of expansion or
#                 synthesizing.
#                 Be careful: expanded/synthesized source code are NOT
#                 reliable to use in your job. More information about the
#                 error can be found in _log directory (if available).
#
#       If this *_status* doesn't exist, it means the expanding/synthesizing
#       is in progress. You and your tool should not touch the source code here.
#
# *_log* directory
#
#       Log files generated during expanding and synthesizing.
#
# *_bundles*
#
#       Extra files generated by hook commands/functions(postprocessor, pp).
#       Typical usage of this directory is storing search indexes for the
#       source code. That was *plugins* directory in srpmix5.
#
#       *_bundles* has its own layout:
#
#	*_bundles*/*pp name* directory
#
#		*_version* file
#
#			The version information of pp.
#
#		*_status* file
#
#                       The pp execution status.
#
# *_uname* directory
#
#	Information about srpmix7 itself.
#
#       *version* file
#
#             The version information of srpmix7.
#
# *__tmp* directory
#
#	Working area of srpmix7. You should not see these.
#
#
# *vanilla* symlink in srpmix5 is gone.
#

# The 7th upper directory specification
# ----------------------------------------------------------------------
# ...


# Interface between main and subcommand
# ----------------------------------------------------------------------
#
# There are two ways to implement a subcommand.
#
# A. xcmd - external subcommand
#
#    An executable XCMD must exist at ${SRPMIX7_XCMD_DIR}/xcmd-${XCMD}.
#
#    XCMD takes following subcommands:
#
#    A.1 help
#    A.2 desc
#    A.3 run "$@"
#
#
# B. icmd - internal subcommand
#
#    A ICMD command is implemented as zsh functions:
#
#    B.1 ${ICMD}_help
#    B.2 ${ICMD}_run
#
#
