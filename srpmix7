#!/bin/zsh
#
# srpmix7 - the 7th implementation of srpmix
#
# Copyright (C) 2015 Red Hat, Inc.
# Copyright (C) 2015 Masatake YAMATO
#
# Author: Masatake YAMATO <yamato@redhat.com>
#
# program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
readonly prefix=srpmix7
readonly PREFIX=${(U)prefix}
readonly SELF=$0:t
readonly c_version=7.0.0

#
# TODO
#    subcommands: diag, deploy(kicked from systemd unit), repair,
#                 attach(generate bundle), spider(?), gc-raw, gc-upper, delete
#
#
#
# Namespace
#
# d_: deploy related
# c_: constant value in files in "raw directory"
# i_: internal subcommand
# p_: file/directory names of lower directory structure
# P_: file/directory names of upper directory structure
# s_: status ofexpansion
# x_: expander
#


#
# Lower directory structure
#
readonly -x p_archives=archives
readonly -x p_pre_build=pre-build
readonly -x p_info=info
readonly -x p_status=_status
readonly -x p_bundles=_bundles
readonly -x p_uname=_uname
readonly -x p_uname_version=$p_uname/version
readonly -x p_log=_log
readonly -x p_stmp=__src_tmp
readonly -x p_xtmp=__expander_tmp

readonly -x s_unknown=unknown
readonly -x s_successful=successful
readonly -x s_bug=BUG
readonly -x s_incomplete=incomplete

readonly -x p_unknown=${(U)${s_unknown}}
readonly -x p_successful=${(U)${s_successful}}
readonly -x p_bug=${(U)${s_bug}}
readonly -x p_incomplete=${(U)${s_incomplete}}

#
# Upper directory structure
#
readonly -x P_sources=sources
readonly -x P_cradles=cradles
readonly -x P_cradle_sources=sources
readonly -x P_cradle_conf=_.cradle
readonly -x P_cradle_log=_log
readonly -x P_cradle_bundles=_bundles

#
# Rearrange zsh behavior
#
set -e
enable -r repeat
setopt EXTENDED_GLOB
autoload -Uz catch
autoload -Uz throw

#
# Rearrange the environment
#
export LANG=C
export LC_ALL=C

#
# Initialize registries
#
typeset -A EVAR
EVAR=(
)

typeset -A EVAR_DEFAULT
EVAR_DEFAULT=(
)

typeset -a ICMD
ICMD=(
)

typeset -A ICMD_DESC
ICMD_DESC=(
)

EVAR[TMPDIR]="Directory where temorary directories are created"

typeset -A REQUIREMENTS
REQUIREMENTS=(
)

#
#
# Utilities
#
#
indent()
{
    local i
    local depth=${1:-1}
    while IFS= read -r; do
	repeat $depth ; do
	    printf "	"
	done
	printf "%s\n" "$REPLY"
    done
}

member()
{
    local elt=$1
    local x
    shift

    for x in "$@"; do
	if [ "$x" = "$elt" ]; then
	    return 0
	fi
    done
    return 1
}

is_available()
{
    -S- whence $1
    return $?
}

require()
{
    local c=$1
    local f=$2

    if [[ -n "$f" ]]; then
	is_available $c || -E- "$f requires $c"
    else
	is_available $c || -E- "$c is not found"
    fi
}

check_requirements()
{
    local class=$1
    local name=$2
    local c

    for c in ${=${REQUIREMENTS[${class}_${name}]}}; do
	require $c $class/$name
    done
}

backtrace()
{
    echo "STACK TRACE"
    echo "-----------"
    echo ${(F)funcstack[2,-1]}
}

is_empty_dir()
{
    local d=$1
    local -a a

    a=( $d/*(N) )
    [[ $#a == 0 ]]
    return $?
}

make_all_readable()
{
    local target=$1

    find $target -type f -exec chmod a+r '{}' '+'
    find $target -type d -exec chmod a+x '{}' '+'
}

make_file_unwritable()
{
    local target=$1

    find $target -type f -exec chmod a-w '{}' '+'
}

# error
-E-()
{

    echo "[ERROR]" "$@"
    backtrace | indent
    exit 1
} 1>&2

-E%-()
{
    local fmt=$1
    shift

    printf "[ERROR] ${fmt}\n" "$@"
    backtrace | indent
    exit 1
} 1>&2

# throw
-T-()
{
    local o=$1
    shift

    echo "[ERROR]" "$@"
    backtrace | indent
    throw $o
} 1>&2

-T%-()
{
    local o=$1
    shift
    local fmt=$1
    shift

    printf "[ERROR] ${fmt}\n" "$@"
    backtrace | indent
    throw $o
} 1>&2

-W-()
{
    echo "[WARNING]" "$@"  1>&2
}

-W%-()
{
    local fmt=$1
    shift

    printf "[WARNING] ${fmt}\n" "$@"  1>&2
}

# silent
-S-()
{
    "$@" > /dev/null 2>&1
    return $?
}

name_prefix()
{
    echo -n ${1[1]}
}

#
#
# Subcommand related operations
#
#
subcommand_enumerate()
{
    local t

    for t in icmd xcmd; do
	${t}_enumerate "$@"
    done | sort
}

subcommand_exist_p()
{
    local c=$1
    local t

    for t in icmd xcmd; do
	if ${t}_exist_p $c; then
	    return 0
	fi
    done

    return 1
}

subcommand_help()
{
    local c=$1
    local t

    for t in icmd xcmd; do
	if ${t}_exist_p $c; then
	    ${t}_help $c
	    return $?
	fi
    done

    return 1
}

subcommand_run()
{
    local c=$1
    shift
    local t


    for t in icmd xcmd; do
	if ${t}_exist_p $c; then
	    ${t}_run $c "$@"
	    return $?
	fi
    done

    return 1
}

#
#
# XCMD related operations
#
#
EVAR[XCMD_DIR]="Directory where external subcommand files are"
EVAR_DEFAULT[XCMD_DIR]="/usr/libexec/${prefix}/xcmd"

xcmd_exist_p()
{
    local c=$1
    test -x ${XCMD_DIR}/$c
}

xcmd_enumerate()
{
    local v=$1
    local x

    for x in ${XCMD_DIR}/xcmd-*(.xN); do
	if [ "$v" = "-v" ]; then
	    =printf "%-20s %s\n" "${${x:t}/xcmd-/}" "$(${x} desc)"

	else
	    echo  $c
	fi
    done

}

xcmd_help()
{
    local c=$1

    if xcmd_exist_p "${c}"; then
	${XCMD_DIR}/$c help
    else
	-E- "No such external subcommand: ${c}"
	return 1
    fi
}

xcmd_run()
{
    local c=$1
    shift 1
    ${XCMD_DIR}/$c run "$@"
}

#
#
# ICMD related operations
#
#
icmd_exist_p()
{
    local c=$1
    local s

    for s in run help; do
	if ! is_available i_${c}_${s}; then
	    return 1
	fi
    done

    return 0
}

icmd_enumerate()
{
    local v=$1
    local c
    for c in ${ICMD[@]}; do
	if [ "$v" = "-v" ]; then
	    =printf "%-20s %s\n" "${c}" ${ICMD_DESC[$c]}
	else
	    echo $c
	fi
    done

}

icmd_help()
{
    local c=$1

    i_${c}_help
}

icmd_run()
{
    local c=$1
    shift 1
    i_${c}_run "$@"
}

#
#
# Environment variable related operations
#
#
evar_enumerate()
{
    local v=$1

    local k
    local n
    for k in  ${(k)EVAR}; do
	n="${PREFIX}_$k"
	if [ "$v" = "-v" ]; then
	    =printf "%-10s	<%s>\n" "${n}" ${(P)n}
	else
	    echo "${n}"
	fi
    done
}

#
#
# Subcommand: inull
#
#
ICMD+=null
ICMD_DESC[null]="do nothing (internal command example)"

i_null_help()
{
    echo i_null_help
}

i_null_run()
{
    echo i_null_run
}

#
#
# Subcommand: help
#
#
ICMD+=help
ICMD_DESC[help]="show help message for subcommand"

i_help_help()
{
    echo "$SELF help [SUBCOMMAND]"
}

i_help_run()
{
    local i=${${0#i_}%_run}
    local c=$1

    if [[ -z "$c" ]]; then
	-E-  "$i: no subcommand given"
    elif subcommand_exist_p "$c"; then
	echo "${(U)c} subcommand usage:"
	subcommand_help $c | indent
    else
	-E-  "$i: no such subcommand: $c"
    fi
}

#
#
# Subcommand: deploy
#
#
ICMD+=deploy
ICMD_DESC[deploy]="deploy a set of source code"
typeset -A CRADLE_TYPE

i_deploy_help()
{
    local k

    echo "$SELF deploy [OPTIONS] CRADLE-FILE DEST-DIR"
    echo
    echo "OPTIONS:"
    {
	echo "	--debug"
	echo "	--trace"
	echo "	--skip-incomplete-ones|-s"
    } | indent
    echo
    echo "Cradle file format:"
    {
	=printf "name=NAME\n"
	=printf "type=CRADLE_TYPE\n"
    } | indent
    echo
    echo "CRADLE_TYPE:"
    for k in ${(k)CRADLE_TYPE}; do
	=printf "%-10s	%s\n" "$k" "${CRADLE_TYPE[$k]}"
    done  | indent
}

i_deploy_run()
{
    local -a args
    args=( "$@" )
    local c=${${0#i_}%_run}
    local opt
    local next
    local debug
    local elt

    local cradle_file
    local -a cradle_conf
    local k v

    local cradle_name
    local cradle_type

    local sources7
    local fn
    local r

    local force_skipping

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--debug|-d)
		debug=yes
		shift
		;;
	    (--skip-incomplete-ones|-s)
		force_skipping=-s
		shift
		;;
	    (--trace|-x)
		set -x
		shift
		;;
	    (--*)
		-E- "$c: unknown long option: $1"
		break
		;;
	    (-*)
		-E- "$c: unknown short option: $1"
		;;
	    (*)
		break
		;;
	esac
    done

    if [[ -z "$1" ]]; then
	-E- "$c: too few arguemnt, no cradle file is given"
    elif [[ ! -e "$1" ]]; then
	-E- "$c: no such directory entry: $1"
    elif [[ ! -f "$1" ]]; then
	-E- "$c: not a file: $1"
    elif [[ ! -r "$1" ]]; then
	-E- "$c: not readable: $1"
    fi

    cradle_file=$1
    shift

    for elt in ${(@f)"$(< ${cradle_file})"[@]}; do
	case $elt in
	    (\#*)
		:
		;;
	    (name=*)
		cradle_name=${elt#name=}
		if [[ ${cradle_name} == */* ]]; then
		    -E-  "${c}: cradle name should not contain '/' (in ${cradle_file})"
		fi
		;;
	    (type=*)
		cradle_type=${elt#type=}
		if ! member "$cradle_type" ${(k)CRADLE_TYPE}; then
		    -E- "$c: no such cradle type: $cradle_type"
		fi
		check_requirements cradle ${cradle_type}
		;;
	    (${cradle_type}_*=*)
		k=${${elt#"${cradle_type}_"}%%=*}

		if [[ -z ${cradle_type} ]]; then
		    -E- "${c}: $k must be defined AFTER type= (in $cradle_file)"
		elif [[ -z ${cradle_name} ]]; then
		    -E- "${c}: $k must be defined AFTER name= (in $cradle_file)"
		fi
		v=${${${elt#*=}//"%{name}"/"${cradle_name}"}//"%{type}"/${cradle_type}}
		cradle_conf+=( "$k" "$v" )
		;;
	    (*)
		-E- "${c}: unexpected line <$elt> (in $cradle_file)"
		;;
	esac
    done

    if [[ -z "$1" ]]; then
	-E- "$c: too few arguemnt, no sources7 directory is given"
    elif [[ ! -e "$1" ]]; then
	-E- "$c: no such directory entry: $1"
    elif [[ ! -d "$1" ]]; then
	-E- "$c: not a directory: $1"
    elif [[ ! -r "$1" ]]; then
	-E- "$c: not readable: $1"
    elif [[ ! -x "$1" ]]; then
	-E- "$c: not executable: $1"
    elif [[ ! -w "$1" ]]; then
	-E- "$c: not writable: $1"
    else
	sources7=$1
	shift
    fi

    fn=d_${cradle_type}_deploy

    {
	local cradledir=${sources7}/${P_cradles}/${cradle_name}
	integer -l cradlefd

	if ! mkdir -p ${cradledir}; then
	    -E- "${c}: failed to create \"${P_cradles}\"(${cradledir}) directory for ${cradle_name}"
	fi

	if ! lock cradlefd ${cradledir}; then
	    -E- "${c}: other process may work on ${cradle_name} (faild to lock ${cradledir})"
	fi

	local cradle=${sources7}/${P_cradles}/${cradle_name}
	local cradle_sources=${cradle}/${P_cradle_sources}
	local cradle_bundles=${cradle}/${P_cradle_bundles}
	local cradle_log=${cradle}/${P_cradle_log}
	local sources=${sources7}/${P_sources}

	if ! mkdir -p  ${cradle_log}; then
	    -E- "${c}: failed to create ${cradle_sources}"
	fi

	{
	    if ! mkdir -p  ${cradle_sources}; then
		-E- "${c}: failed to create ${cradle_sources}"
	    fi

	    if ! mkdir -p  ${cradle_bundles}; then
		-E- "${c}: failed to create ${cradle_bundles}"
	    fi

	    if ! mkdir -p ${sources}; then
		-E- "${c}: failed to create ${sources}"
	    fi

	    progress_init "${cradle_name}" ${cradle_log}/d_progress.log ${cradle_log}/d_critical.log
	    "${fn}" ${cradle_name} cradle_conf ${sources7} ${force_skipping}
	    r=$?
	    progress_fini "${cradle_name}"

	    {
		local -A conf
		echo "name=${cradle_name}"
		echo "type=${cradle_type}"

		conf=( ${cradle_conf[@]} )
		for k in ${(k)conf}; do
		    echo "${cradle_type}_${k}=${conf[$k]}"
		done

	    } > ${cradle}/${P_cradle_conf}

	} 2>&1 | tee ${cradle_log}/d.log

	unlock $cradlefd
    }
}

CRADLE_TYPE[dir]="flatten directory"
REQUIREMENTS[cradle_dir]="flock setfattr"

typeset -A PROGRESS_REPORT_CHAR

readonly -x r_unknown_file='?'
PROGRESS_REPORT_CHAR[$r_unknown_file]="unknown file for expanding"

readonly -x r_broken_input='<'
PROGRESS_REPORT_CHAR[$r_broken_input]="MAYBE INPUT FILE IS BROKEN"

readonly -x r_unexpected_env='>'
PROGRESS_REPORT_CHAR[$r_broken_env]="UNEXPECTED RUNTIME ENVIRONMENT"

readonly -x r_locked='_'
PROGRESS_REPORT_CHAR[$r_locked]="cannot get file lock"

readonly -x r_skipped=','
PROGRESS_REPORT_CHAR[$r_skipped]="already successfully deployed"

readonly -x r_forced_skipping=';'
PROGRESS_REPORT_CHAR[$r_forced_skipping]="forced skipping failed one"

readonly -x r_successful='.'
PROGRESS_REPORT_CHAR[$r_successful]="successfully expanded"

readonly -x r_bug='!'
PROGRESS_REPORT_CHAR[$r_bug]="MAYBY A BUG IN EXPAND SUBCOMMAND"

readonly -x r_failed_in_prep='f'
PROGRESS_REPORT_CHAR[$r_failed_in_prep]="failed in %prep"

readonly -x r_unknown='*'
PROGRESS_REPORT_CHAR[$r_unknown]="unkonown"

progress_cradle=
progress_source=
integer progress_fd
integer critical_fd

typeset -A progress_counter
typeset -A progress_details

progress_init()
{
    progress_cradle=$1
    local progress_file=$2
    local critical_file=$3
    local k

    exec {progress_fd}> ${progress_file}
    exec {critical_fd}> ${critical_file}

    progress_counter[TOTAL]=0
    progress_counter[MSG]=0
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	progress_counter[$k]=0
    done

    progress_counter[MSG]=0
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	progress_details[$k]=""
    done

    echo "Cradle: [$progress_cradle]"
    echo '======================================================================'
    echo -n START:
    date
    {
	echo Cradle: $cradle
	echo '======================================================================'
	echo -n START:
	date
	echo

    } >&${progress_fd}
}

progress_fini()
{
    progress_cradle=$1
    local k
    local l

    echo
    echo -n END:
    date
    echo
    =printf "%-35s%s %25s\n"   "TOTAL"  " - " "${progress_counter[TOTAL]}"
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	=printf "%-35s(%c) %25s\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k" "${progress_counter[$k]}"
    done | sort

    echo
    for k in ${(k)PROGRESS_REPORT_CHAR}; do
	if [[ -z "${progress_details[$k]}" ]]; then
	    continue
	else
	    case $k in
		($r_skipped|$r_forced_skipping|$r_successful)
		continue
		;;
	    esac
	fi
	=printf "%s(%c)\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k"
	echo '----------------------------------------------------------------------'
	for l in ${(f)${progress_details[$k]}}; do
	    echo $l
	done
    done

    {
	echo
	echo -n END:
	date
	echo
	=printf "%-35s%s %25s\n"   "TOTAL"  " - " "${progress_counter[TOTAL]}"
	for k in ${(k)PROGRESS_REPORT_CHAR}; do
	    =printf "%-35s(%c) %25s\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k" "${progress_counter[$k]}"
	done | sort

	echo
	for k in ${(k)PROGRESS_REPORT_CHAR}; do
	    if [[ -z "${progress_details[$k]}" ]]; then
		continue
	    else
		case $k in
		    ($r_skipped|$r_forced_skipping|$r_successful)
			continue
			;;
		esac
	    fi
	    =printf "%s(%c)\n"   "${PROGRESS_REPORT_CHAR[$k]}" "$k"
	    echo '----------------------------------------------------------------------'
	    for l in ${(f)${progress_details[$k]}}; do
		echo $l
	    done
	done
    } >&${progress_fd}


    exec {critical_fd}>&-
    exec {progress_fd}>&-
}

progress_source()
{
    progress_source=$1
}

progress_newline_maybe()
{
    if [[ $1 -gt 68 ]]; then
	echo "|"
    else
	return 1
    fi
}

progress_report()
{
    local s=$1
    local dloc=$2

    echo -n "$s"
    echo -n "$s" >&${progress_fd}

    (( progress_counter[TOTAL] += 1 ))
    (( progress_counter[MSG] += 1 ))
    (( progress_counter[$s] += 1))

    if [[ -n "${dloc}" ]]; then
	progress_details[$s]+=$(=printf "%50s => %-20s\n" "${progress_source:t}" "${dloc:t}")"\n"
    else
	progress_details[$s]+=$(=printf "%50s\n" "${progress_source:t}")"\n"
    fi

    case "$s" in
	(${r_broken_input}|${r_unexpected_env}|${r_bug}|"${r_unknown}")
	    echo "$s(${PROGRESS_REPORT_CHAR[$s]})" "${progress_source}" "=>" "${dloc}"
	    echo "$s(${PROGRESS_REPORT_CHAR[$s]})" "${progress_source}" "=>" "${dloc}" >&${critical_fd}
	    ;;
    esac

    progress_newline_maybe ${progress_counter[MSG]} && progress_counter[MSG]=0
    progress_newline_maybe ${progress_counter[MSG]} >&${progress_fd} && progress_counter[MSG]=0
}

d_dir_deploy()
{
    local self=dir
    local cradle_name=$1
    local -A conf
    conf=( ${(P)2[@]} )
    local sources7=$3
    shift 3
    local force_skipping

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (-s)
		force_skipping=yes
		shift
		;;
	esac
    done

    local cradle=${sources7}/${P_cradles}/${cradle_name}
    local cradle_sources=${cradle}/${P_cradle_sources}
    local cradle_log=${cradle}/${P_cradle_log}
    local sources=${sources7}/${P_sources}

    local dir=${conf[dir]}
    local src_name
    local src_version
    local expander
    local src
    local dest
    local r

    if [[ -z "${dir}" ]]; then
	-E- "${c}: ${self}_dir is not given in cradle ${cradle_name}"
    elif ! [[ -e "${dir}" ]]; then
	-E- "$c: no such directory entry: ${dir} specified in cradle ${cradle_name}"
    elif ! [[ -r "${dir}" ]]; then
	-E- "$c: cannot read directory: ${dir} specified in cradle ${cradle_name}"
    elif ! [[ -x "${dir}" ]]; then
	-E- "$c: cannot traverse directory: ${dir} specified in cradle ${cradle_name}"
    fi

    for src in ${dir}/*; do
	progress_source "${src}"

	case "${src}" in
	    (*.src.rpm)
		expander=srpm
		;;
	    (*)
		progress_report ${r_unknown_file}
		continue
		;;
	esac

	if ! src_name=$(pname_name ${expander} $src); then
	    progress_report ${r_broken_input}
	    continue
	fi
	if ! src_version=$(pname_version ${expander} $src); then
	    progress_report ${r_broken_input}
	    continue
	fi

	dest=${sources}/$(name_prefix "${src_name}")/${src_name}/${src_version}--${expander}

	if ! mkdir -p ${dest}; then
	    -W- "${c}: skip [${cradle_name}]${src} because creating dir:${dest} is failed"
	    progress_report "${r_unexpected_env}" ${dest}
	    continue
	fi

	set +e
	{
	    integer -l destfd
	    local s=${dest}/${p_status}

	    if ! lock destfd ${dest}; then
		-W- "${c}: other process may work on [${cradle_name}]${src}/${expander} (faild to lock ${dest})"
		progress_report "${r_locked}" ${dest}
		throw "${r_locked}"
	    fi

	    if [[ -f ${s} ]]; then
		case $(< ${s}) in
		    (${s_successful})
			progress_report "${r_skipped}" ${dest}
			throw "${r_skipped}"
			;;
		    (${s_incomplete})
			if [[ "${force_skipping}" == yes ]]; then
			    progress_report "${r_forced_skipping}" ${dest}
			    throw "${r_forced_skipping}"
			fi
			;;
		esac
	    fi

	    rm -rf ${dest}/*(N)
	    (
		# TODO: TIMEOUT
		subcommand_run expand --stype file --sloc $src --dtype dir --dloc ${dest} ${expander}
	    )
	    r=$?

	    case $r in
		(0) progress_report "${r_successful}" ${dest} ;;
		(1) progress_report "${r_bug}" ${dest} ;;
		(2) progress_report "${r_failed_in_prep}" ${dest};;
		(*) progress_report "${r_unknown}" ${dest};;
	    esac
	} always {
	    if catch '*'; then
		:
	    fi

	    {
		local base=${cradle_sources}/$(name_prefix "${src_name}")/${src_name}
		# e.g. ln -s -t /tmp/8 -r /tmp/9/a
		: &&
		    mkdir -p "${base}" &&
		    ln -f -s -t "${base}" -r ${dest}
	    }

	    {
		# attr -q -l tmp/sources/r/rhs-hadoop-install/2_29-1.el6rhs--srpm
		local key="${prefix}-ref-cradle-${cradle_name}"
		setfattr -n user.${key} -v "${c_version}" ${dest}
	    }
	    if [[ -n "${destfd}" ]]; then
		unlock $destfd
	    fi
	}
	set -e
    done

    return 0
}


CRADLE_TYPE[yum]="yumrepo (not implemented yet)"
REQUIREMENTS[cradle_yumrepo]="yum repoquery"


#
#
# Subcommand: expand
#
#
ICMD+=expand
ICMD_DESC[expand]="expand source code"

typeset -A EXPAND_STYPE
typeset -A EXPAND_DTYPE
typeset -A EXPANDER

i_expand_help()
{
    local k

    =printf "%s\\\\\n" "$SELF expand [OPTIONS] EXPANDER [EXPANDER-OPTION]..."
    {
	=printf "  %s \\\\\n" "--stype=STYPE --sloc=SLOCATION"
	=printf "  %s \\\\\n" "--dtype=DTYPE --dloc=DLOCATION"
	echo
    } | indent
    echo "OPTIONS:"
    {
	echo "	--action-when-error=abort|continue*"
	echo "	--debug"
	echo "	--quit-after=optparse|prepare"
	echo "	--trace"
	echo "	--help-expander=EXPANDER"
	echo "	--help-stype=STYPE"
	echo "	--help-dtype=DTYPE"
    }
    echo "STYPE:"
    for k in ${(k)EXPAND_STYPE}; do
	=printf "%-10s	%s\n" "$k" "${EXPAND_STYPE[$k]}" | indent
    done

    echo "DTYPE:"
    for k in ${(k)EXPAND_DTYPE}; do
	=printf "%-10s	%s\n" $k "${EXPAND_DTYPE[$k]}" | indent
    done

    echo "EXPANDER:"
    for k in ${(k)EXPANDER}; do
	=printf "%-10s	%s\n" $k "${EXPANDER[$k]}" | indent
    done

}

#
# TODO:
#                    stype: apt-get,rsync
#                 expander: deb
# other interesting things: npm, cpan, pypi,
#
# npm view jstags dist.tarball > /dev/null => url: vanilla
#

#
# Return value
# 0: successful
# 1: error before expanding (critical error)
# 2: error in expanding
# 3: error after expanding
#
# If the return value is 3, it must be recorded somewhere other place.
i_expand_run()
{
    local -a args
    args=( "$@" )
    local c=${${0#i_}%_run}
    local opt
    local next
    local action_when_error=continue

    local src
    local stype
    local sloc
    local -a slocs_local
    local -r stype_default=file

    local dest
    local dtype
    local dloc
    local -r dtype_default=dir

    local expander
    local expander_default=srpm

    local checker

    local debug
    local quit_after

    local t
    local s
    local r

    while [[ $# -gt 0 ]]; do
	case $1 in
	    (--help|-h)
		i_${c}_help
		return 0
		;;
	    (--[^=]#=*)
		opt=${1%%=*}
		next=${1#*=}
		shift 1
		set -- "$opt" "$next" "$@"
		;;
	    (--help-expander|--help-stype|--help-dtype)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		fi
		x_help_${opt#--help-} $2
		return 0
		;;
	    (--action-when-error)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		else
		    case $2 in
			(abort|continue) action_when_error=$2;;
			(*) -E- "$c: unexpected value for $opt: $2";;
		    esac
		fi
		shift 2
		;;
	    (--debug|-d)
		debug=yes
		shift
		;;
	    (--dtype)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${dtype}" ]]; then
		    if [[ ${dtype} != $2 ]]; then
			-E- "$c: dtype is already given as ${dtype}: ${opt}=$2"
		    else
			dtype=$2
		    fi
		else
		    dtype=$2
		fi
		shift 2
		if ! member "$dtype" ${(k)EXPAND_DTYPE}; then
		    -E- "$c: no such dest type: $dtype"
		fi
		;;
	    (--dloc)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${dloc}" ]]; then
		    -E- "$c: dloc is already given as ${dloc}: ${opt}=$2"
		else
		    dloc=$2
		    shift 2
		fi
		;;
	    (--stype)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${stype}" ]]; then
		    if [[ ${stype} != $2 ]]; then
			-E- "$c: stype is already given as ${stype}: ${opt}=$2"
		    else
			stype=$2
		    fi
		else
		    stype=$2
		fi
		shift 2
		if ! member "$stype" ${(k)EXPAND_STYPE}; then
		    -E- "$c: no such src type: $stype"
		fi
		;;
	    (--sloc)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		elif [[ -n "${sloc}" ]]; then
		    -E- "$c: sloc is already given as ${sloc}: ${opt}=$2"
		else
		    sloc=$2
		    shift 2
		fi
		;;
	    (--quit-after)
		opt=$1
		if [[ -z "$2" ]]; then
		    -E- "$c: value for $opt is not given"
		else
		    case "$2" in
			(optparse|prepare) quit_after=$2;;
			(*) -E- "$c: unexpected value for $opt: $2" ;;
		    esac
		fi
		shift 2
		;;
	    (--trace|-x)
		set -x
		shift
		;;
	    (--*)
		: ${expander:=${expander_default}}
		break
		;;
	    (-*)
		-E- "$c: unknown option: $1"
		;;
	    (*)
		expander=$1
		shift
		if ! member "$expander" ${(k)EXPANDER}; then
		    -E- "$c: unknown expander: $expander"
		fi
		break
		;;
	esac
    done

    if [[ -z "$sloc" ]]; then
	-E- "$c: no SLOC is given"
    fi
    if [[ -z "$stype" ]]; then
	stype=${stype_default}
    fi

    check_requirements stype ${stype}
    checker="x_src_${stype}_precheck"
    if is_available $checker; then
	$checker "$sloc"
    fi

    if [[ -z "$dtype" && -z "$dloc" ]]; then
	dtype=${dtype_default}
	dloc=.
    elif [[ -z "$dtype" ]]; then
	dtype=${dtype_default}
    elif [[ -z "$dloc" ]]; then
	if [[ "$dtype" == "dir" ]]; then
	    dloc=.
	else
	    -E- "$c: no DLOC is given"
	fi
    fi
    checker="x_dest_${dtype}_check"
    check_requirements dtype ${dtype}
    if is_available $checker; then
	"$checker" "$dloc"
    fi

    #
    # TODO: convert to per backend funcs.
    #
    if [[ -z "$expander" ]]; then
	case "$stype" in
	    (yds)
		expander_default=srpm
		;;
	    (yd)
		expander_default=brpm
		;;
	    (npm)
		expander_default=vanilla
		;;
	    (file|wget)
		case "$sloc" in
		    (*.src.rpm)
			expander_default=srpm
			;;
		    (*.rpm)
			expander_default=brpm
			;;
		    (*.lcopy)
			expander_default=lcopy
			;;
		    (*.zip|*.gz|*.bz2|*.xz)
			expander_default=vanilla
			;;
		esac
		;;
	esac
	expander=${expander_default}
    fi
    if [[ -z "$expander" ]]; then
	-E- "$c: no EXPANDER is given"
    fi

    checker="x_expand_${expander}_check"
    check_requirements expander ${expander}
    if is_available "$checker"; then
	"$checker"
    fi

    if [[ "${debug}" == "yes" ]]; then
	echo stype: $stype
	echo sloc: $sloc
	echo dtype: $dtype
	echo dloc: $dloc
	echo expander: $expander
    fi

    if [[ "$quit_after" == "optparse" ]]; then
	exit 0
    fi

    #
    # TODO: check the status of $dloc
    #       if not expanded yet, lock the directory.
    #
    {
	if ! t=$(mktemp --tmpdir --directory ${SELF}-EXPAND-${expander}.XXXXXXXXXX) ; then
	    throw Creation
	elif [[ "${debug}" == "yes" ]]; then
	    echo tmpdir: $t
	fi

	if ! x_prepare $t; then
	    throw Preparation
	else
	    {
		: &&
		    echo "${c_version}" > $t/$p_uname/x_version &&
		    echo "${expander}"  > $t/$p_uname/expander  &&
		    echo "${args[@]}"   > $t/$p_uname/x_args    &&
		    echo "${stype}"     > $t/$p_uname/x_stype   &&
		    echo "${sloc}" > $t/$p_uname/x_sloc &&
		    echo "${dtype}"     > $t/$p_uname/x_dtype &&
		    echo "${dloc}" > $t/$p_uname/x_dloc
	    } || throw Preparation
	fi
	if [[ "$quit_after" == "prepare" ]]; then
	    exit 0
	fi

	set +e
	if x_src_${stype}_transfer ${sloc} $t; then
	    slocs_local=( $t/$p_stmp/*(N) )
	    echo "${slocs_local[@]}" > $t/$p_uname/x_slocs_local || throw Preparation
	    if [[ $#slocs_local == 0 ]]; then
		throw STransfer
	    fi
	else
	    throw STransfer
	fi
	set -e


	set +e
	if [[ $#slocs_local == 1 ]]; then
	    # Passing a file under the temporary directory.
	    checker="x_src_${stype}_postcheck"
	    if is_available $checker; then
		$checker "${slocs_local[1]}"
	    fi
	    x_expand_${expander}_run "${slocs_local[1]}" "$t" "$@"
	else
	    # Passing the temporary directory
	    x_expand_${expander}_run  $t/$p_stmp "$t" "$@"
	fi
	s=$?
	set -e
    } always {
	local delayed_emsg

	if catch Creation; then
	    r=1
	    if [[ "$action_when_error" == continue ]]; then
		echo "$s_bug" "(failed to create working directory for expanding)\n" > $t/.$p_status
		ln -f -s -r $t/$p_status $t/$p_bug
	    else
		delayed_emsg="$c: failed to create working directory for expanding"
	    fi
	elif catch Prepare; then
	    r=1
	    if [[ "$action_when_error" == continue ]]; then
		echo "$s_bug" "(failed to prepare a directory for expansion)\n" > $t/.$p_status
		ln -f -s -r $t/$p_status $t/$p_bug
	    else
		delayed_emsg="$c: failed to prepare a directory for expansion"
	    fi
	else

	    if catch STransfer; then
		r=1
		if [[ "$action_when_error" == continue ]]; then
		    echo "$s_bug" "(failed to transfer data source from $sloc to $t by $stype)\n" > $t/.$p_status
		    ln -f -s -r $t/$p_status $t/$p_bug
		else
		    delayed_emsg="$c: failed to transfer data source from $sloc to $t by $stype"
		fi
	    elif [[ "$s" == 0 ]]; then
		r=0
		echo $s_successful > $t/.$p_status
		ln -f -s -r $t/$p_status $t/$p_successful
	    else
		if [[ ! -e $t/$p_incomplete ]]; then
		    ln -f -s -r $t/$p_status $t/$p_incomplete
		fi
		r=2
	    fi
	    if [[ "$s" == 0 || "$action_when_error" == continue ]]; then
		if x_dest_${dtype}_transfer "$t" "$dloc"; then
		    x_dest_${dtype}_commit "$dloc"
		    #
		    # TODO; COMMIT_HOOK
		    #
		else
		    delayed_emsg="$c: failed to transfer expanded data to $dtype:$dloc from $t"
		    r=3
		fi
	    fi
	fi

	if [[ "${debug}" == "yes" ]]; then
	    :
	else
	    rm -rf "$t"
	fi

	if [[ -n "${delayed_emsg}" ]]; then
	    -E- "${delayed_emsg}"
	fi
    }

    return $r
}

x_help_expander()
{
    local expander=$1
    local c

    if [[ -z "${EXPANDER[${expander}]}" ]]; then
	-E- "no such expander: ${expander}"
    fi

    x_expand_${expander}_help
    echo "Requirements:"
    for c in ${REQUIREMENTS[expander_${expander}]}; do
	echo "	$c"
    done
}

x_help_stype()
{
    local stype=$1
    local c

    if [[ -z "${EXPAND_STYPE[${stype}]}" ]]; then
	-E- "no such stype: ${stype}"
    fi

    x_src_${stype}_help
    echo "Requirements:"
    for c in ${REQUIREMENTS[stype_${stype}]}; do
	echo "	$c"
    done
}

x_help_dtype()
{
    local dtype=$1
    local c

    if [[ -z "${EXPAND_DTYPE[${dtype}]}" ]]; then
	-E- "no such dtype: ${dtype}"
    fi

    x_dest_${dtype}_help
    echo "Requirements:"
    for c in ${REQUIREMENTS[dtype_${dtype}]}; do
	echo "	$c"
    done
}

#
# TODO: Allow symlink from pre-build to archive
#
x_prepare()
{
    local d=$1
    local elt

    for elt in $p_archives $p_pre_build $p_info $p_bundles $p_uname $p_log $p_xtmp $p_stmp; do
	if ! mkdir ${d}/${elt}; then
	    return 1
	fi
    done

    elt=.$p_status
    echo 'unknown' > ${d}/${elt}

    return 0
}


#
# STYPES
#
EXPAND_STYPE[npm]="node package"
REQUIREMENTS[stype_npm]="npm"
x_src_npm_help()
{
    echo "Usage:"
    echo "	... expand --stype=npm --sloc=NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=npm --sloc=uniator --dtype=dir --dloc=/tmp vanilla"
}

x_src_npm_transfer()
{
    local name=$1
    local t=$2
    local url
    local s

    url=$(npm view ${name} dist.tarball 2> $t/$p_log/x_s_npm-view-dist-tarball.log)
    s=$?
    echo "$s $url" >> $t/$p_log/x_s_npm-view-dist-tarball.log

    if [[ "${s}" != 0 ]]; then
	return $s
    elif [[ -z "$url" ]]; then
	echo "npm: returned URL is empty" >> $t/$p_log/x_s_npm-view-dist-tarball.log
	return 1
    fi

    x_src_wget_transfer "$url" $t
    return $?
}

EXPAND_STYPE[file]="regular file"
REQUIREMENTS[stype_file]=""

x_src_file_help()
{
    echo "Usage:"
    echo "	... expand --stype=file --sloc=FILE ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=file --stype=/tmp/coreutils-8.22-11.el7.src.rpm --dtype=dir --dloc=/tmp srpm"
}
x_src_file_precheck()
{
    local sloc=$1

    if [[ ! -e "$sloc" ]]; then
	-E- "$c: no such file: $sloc"
    elif [[ ! -r "$sloc" ]]; then
	-E- "$c: file unreadable: $sloc"
    fi
}

x_src_file_postcheck()
{
    local sloc=$1

    if [[ ! -e "$sloc" ]]; then
	-T- STransfer "$c: no such file: $sloc"
    elif [[ ! -r "$sloc" ]]; then
	-T- STransfer "$c: file unreadable: $sloc"
    fi
}

x_src_file_transfer()
{
    local sloc=$1
    local t=$2

    local abs_sloc
    local s


    ln $sloc $t/$p_stmp/${sloc:t} > $t/$p_log/x_s_file-ln-transfer.log 2>&1
    s=$?
    echo $s > $t/$p_log/x_s_file-ln-transfer.status

    if [[ "${sloc[1]}" == '/' ]]; then
	abs_sloc=${sloc}
    else
	abs_sloc=$(pwd)/$sloc
    fi

    if [[ $s != 0 ]]; then
	( cd $t/$p_stmp && cp -s $abs_sloc ./${sloc:t} ) > $t/$p_log/x_s_file-cp-transfer.log 2>&1
	s=$?
	echo $s > $t/$p_log/x_s_file-cp-transfer.status
    fi

    return $s
}

EXPAND_STYPE[wget]="something specified with URL"
REQUIREMENTS[stype_wget]="wget"
x_src_wget_help()
{
    echo "Usage:"
    echo "	... expand --stype=wget --sloc=URL ..."
}
x_src_wget_transfer()
{
    local sloc=$1
    local t=$2
    local s

    ( cd $t/$p_stmp;
      wget $sloc;
      exit $? ) > $t/$p_log/x_s_wget-transfer.log 2>&1

    s=$?
    echo $s > $t/$p_log/x_s_wget-transfer.status
    return $s
}

EXPAND_STYPE[git]="git repository"
REQUIREMENTS[stype_git]=""
x_src_git_help()
{
    echo "Usage:"
    echo "	... expand --stype=git --sloc=http://... ..."
    echo "	... expand --stype=git --sloc=https://... ..."
    echo "	... expand --stype=git --sloc=git://... ..."
    echo "	... expand --stype=git --sloc=[http://...]branch ..."
    echo "	... expand --stype=git --sloc=[https://...]branch ..."
    echo "	... expand --stype=git --sloc=[git://...]branch ..."
}
x_src_git_precheck()
{
    local sloc=$1

    if  ! [[ ( "$sloc" =~ "^(http|https|git)://.*" )
	|| ( "$sloc" =~ "^\[(HTTP|https|git)://.*\].*" ) ]]; then
	-E- "$c: unexpected git repo URL: $sloc"
    else
	return 0
    fi
}
x_src_git_postcheck()
{
    x_src_file_postcheck $1
}

x_src_git_transfer()
{
    local sloc=$1
    local t=$2
    local s

    local repo
    local branch

    case "$sloc" in
	(\[*\]*)
	    repo=${${sloc%\]*}[2,-1]}
	    branch=${sloc#\[*\]}

	    if [[ -z "${repo}" ]]; then

	    fi
	    lcopy_genconf git "$repo" --branch "$branch"
	    ;;
	(*)
	    lcopy_genconf git "$sloc"
	    ;;
    esac  > ${t}/$p_stmp/_.lcopy 2> $t/$p_log/x_s_git-transfer.log

    s=$?
    echo $s > $t/$p_log/x_s_git-transfer.status
    return $s
}


EXPAND_STYPE[yds]="a file downloaded by yumdownloader --source"
REQUIREMENTS[stype_yds]="yumdownloader"
x_src_yds_help()
{
    echo "Usage:"
    echo "	... expand --stype=yds --sloc=\[REPO\]NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=yds --sloc=[rhel-7-server-source-rpms]coreutils --dtype=dir --dloc=/tmp srpm"
    echo "	srpmix7 expand --stype=yds --sloc=coreutils --dtype=dir --dloc=/tmp srpm"
    echo "	srpmix7 expand --stype=yds --sloc=coreutils-8.22-11.el7 --dtype=dir --dloc=/tmp srpm"
}

x_src_yds_precheck()
{
    :
}

x_src_yds_postcheck()
{
    x_src_file_postcheck $1
}

x_src_yds_transfer()
{
    local sloc=$1
    local t=$2
    local pname
    local repo
    local s

    case "$sloc" in
	(\[*\]*)
	    pname=${sloc#\[*\]}
	    repo=${${sloc%\]*}[2,-1]}
	    yumdownloader --source --destdir ${t}/$p_stmp --disablerepo '*' --enablerepo "$repo" $pname
	    ;;
	(*)
	    yumdownloader --source --destdir ${t}/$p_stmp $sloc
	    ;;
    esac > $t/$p_log/x_s_yds-transfer.log 2>&1
    s=$?
    echo $s > $t/$p_log/x_s_yds-transfer.status
    return $s
}

EXPAND_STYPE[yd]="a file downloaded by yumdownloader(no --source)"
REQUIREMENTS[stype_yd]="yumdownloader"
x_src_yd_help()
{
    echo "Usage:"
    echo "	... expand --stype=yd --sloc=\[REPO\]NAME ..."

    echo "Example:"
    echo "	srpmix7 expand --stype=yd --sloc=[rhel-7-server-source-rpms]coreutils --dtype=dir --dloc=/tmp brpm"
    echo "	srpmix7 expand --stype=yd --sloc=coreutils --dtype=dir --dloc=/tmp brpm"
    echo "	srpmix7 expand --stype=yd --sloc=coreutils-8.22-11.el7 --dtype=dir --dloc=/tmp brpm"
}

x_src_yds_precheck()
{
    :
}

x_src_yd_postcheck()
{
    x_src_file_postcheck $1
}

x_src_yd_transfer()
{
    local sloc=$1
    local t=$2
    local pname
    local repo
    local s

    case "$sloc" in
	(\[*\]*)
	    pname=${sloc#\[*\]}
	    repo=${${sloc%\]*}[2,-1]}
	    yumdownloader --destdir ${t}/$p_stmp --disablerepo '*' --enablerepo "$repo" $pname
	    ;;
	(*)
	    yumdownloader --destdir ${t}/$p_stmp $sloc
	    ;;
    esac > $t/$p_log/x_s_yd-transfer.log 2>&1
    s=$?
    echo $s > $t/$p_log/x_s_yd-transfer.status
    return $s
}


#
# DTYPES
#
EXPAND_DTYPE[dir]="sources7 lower directory layout"
REQUIREMENTS[dtype_dir]="cp tar"
x_dest_dir_help()
{
    :
}

x_dest_dir_check()
{
    local dloc=$1

    if [[ ! -e "$dloc" ]]; then
	-E- "$c: no such directory: $dloc"
    elif [[ ! -d "$dloc" ]]; then
	-E- "$c: not directory: $dloc"
    elif [[ ! -w "$dloc" ]]; then
	-E- "$c: directory unwritable: $dloc"
    fi
}

x_dest_dir_transfer()
{
    local src=$1
    local dest=$2
    local s=0

    for x in ${src}/*(N) ${src}/._*(N); do
	if [[ "${x:t}" == __* ]]; then
	    # __tmp should not be transferred.
	    continue
	fi

	if [[ "${x:t}" == "${p_log}" && $(< ${src}/.${p_status}) == ${s_successful} ]]; then
	    # compress the log files only successful
	    if ! { (cd "${x:h}" && tar Jcf "${p_log}".tar.xz ./${p_log} ) \
		       && rm -rf ${x} && cp -r ${x}.tar.xz "${dest}" }; then
		s=1
		break
	    fi
	elif ! cp -r $x "${dest}"; then
	    # just copy
	    s=1
	    break
	fi
    done

    return $s
}

x_dest_dir_commit()
{
    local dest=$1
    local s=0

    mv ${dest}/.$p_status ${dest}/$p_status
    return $?
}

#
# EXPANDERS
#
EXPANDER[vanilla]="unarchivers frontend"
REQUIREMENTS[expander_vanilla]="tar unzip gunzip bunzip2 unxz"
x_expand_vanilla_help()
{
    :
}

x_expand_vanilla_run()
{
    local archive=$1
    local t=$2
    shift 2
    local s

    echo "$@"  > $t/$p_uname/x_vanilla_args

    vanilla $archive $t/$p_xtmp > "$t/$p_log/x_vanilla.log" 2>&1
    s=$?
    echo $s > "$t/$p_log/x_vanilla.status"

    if [[ -d "$t/$p_xtmp" ]] && ( ! is_empty_dir "$t/$p_xtmp" ); then
	mv $t/$p_xtmp/*	$t/$p_archives
    fi

    make_all_readable    "$t/$p_archives"
    make_file_unwritable "$t/$p_archives"


    return $s
}

x_expand_vanilla_check()
{
    :
}

EXPANDER[brpm]="binary rpm"
REQUIREMENTS[expander_brpm]="rpm2cpio cpio rpm"

x_expand_brpm_help()
{
    :
}

x_expand_brpm_run()
{
    local brpm=$1
    local t=$2
    shift 2

    local s

    echo "$@"  > $t/$p_uname/x_brpm_args

    echo "rpm2cpio" > $t/$p_uname/x_brpm_method
    for tag in $(rpm --nosignature --querytags); do
	rpm --nosignature -qp --queryformat '[%{'${tag}'}\n]' "${brpm}" \
	    > $t/$p_info/brpm_query_${tag//\//_/}
    done

    {
	rpm2cpio $brpm | (cd $t/$p_xtmp && cpio -dim) > "$t/$p_log/x_brpm-rpm2cpio--cpio-dim.log" 2>&1
	s=$?
	echo $s > "$t/$p_log/x_brpm-rpm2cpio-cpio-dim.status"
	if [[ $s != 0 ]]; then
	    throw RPM2CPIO__CPIO_DIM
	fi
    } always {
	if catch RPM2CPIO__CPIO_DIM; then
	    =printf "%s (failed in rpm2cpio or cpio -dim for %s)\n" $s_incomplete ${brpm:t} > $t/.$p_status
	fi

	if [[ -d "$t/$p_xtmp" ]] && ( ! is_empty_dir "$t/$p_xtmp" ); then
	    mv $t/$p_xtmp/*	$t/$p_archives
	fi
    }

    make_all_readable    "$t/$p_archives"
    make_file_unwritable "$t/$p_archives"

    return $s

}
x_expand_brpm_check()
{
    :
}

EXPANDER[srpm]="source rpm"
REQUIREMENTS[expander_srpm]="rpm rpmbuild"

x_expand_srpm_name_name()
{
    rpm --nosignature -qp --queryformat "%{NAME}\n" $1
}

x_expand_srpm_name_version()
{
    rpm --nosignature -qp --queryformat "%{VERSION}-%{RELEASE}\n" $1
}

x_expand_srpm_help()
{
    :
}

x_expand_srpm_run()
{
    local srpm=$1
    local t=$2
    shift 2

    local tag
    local -a t_spec
    local s

    rpm --version  > $t/$p_uname/x_srpm_rpm_command_version
    echo "$@"  > $t/$p_uname/x_srpm_args

    echo "install-build-pre" > $t/$p_uname/x_srpm_method
    #
    # TODO: Separate mock method and ibp method.
    #
    for tag in $(rpm --nosignature --querytags); do
	rpm --nosignature -qp --queryformat '[%{'${tag}'}\n]' "${srpm}" \
	    > $t/$p_info/srpm_query_${tag//\//_/}
    done

    {
	rpm --nosignature --define="_topdir $t/$p_xtmp" -ivh "${srpm}" \
	    > "$t/$p_log/x_srpm-rpm-ivh.log" 2>&1
	s=$?
	echo $s > "$t/$p_log/x_srpm-rpm-ivh.status"
	if [[ $s != 0 ]]; then
	    throw RPM_I
	fi

	#
	# rhev-agent-2.3.16-3.el6.src.rpm contains gdm*.src.rpm as SOURCE1.
	# So two spec files, one for rhev-agent and one for gdm are in SPECS directory.
	# This becomes a trouble whev moving SPECS/*.spec  specs/srpm.spec.
	# So The spec file name is recorded to t_spec here. The spec file for
	# gdm generated while rpmbuild-bp is throws away when moving.
	#
	t_spec=( $t/$p_xtmp/SPECS/*.spec(N) )
	if [[ ${#t_spec} != 1 ]]; then
	    throw WRONG_SPEC_NUM
	fi

	rpmbuild --define="_topdir $t/$p_xtmp" --nodeps --target=x86_64 -bp ${t_spec[1]} \
		 > "$t/$p_log/x_srpm-rpmbuild-bp.log" 2>&1 \
		 < <(yes "")
	s=$?
	echo $s > "$t/$p_log/x_srpm-rpmbuild-bp.status"
	if [[ $s != 0 ]]; then
	    throw RPMBUILD_BP
	fi
    } always {

	if catch RPM_I; then
	    =printf "%s (failed in rpm -ivh %s)\n" $s_incomplete ${srpm:t} > $t/.$p_status
	elif catch WRONG_SPEC_NUM; then
	    =printf "%s (wrong number of spec file(s): ${#t_spec})\n" $s_incomplete > $t/.$p_status
	elif catch RPMBUILD_BP; then
	    =printf "%s (failed in rpmbuild -bp srpm.spec)\n" $s_incomplete > $t/.$p_status
	    ln -f -s -r $t/$p_log/x_srpm-rpmbuild-bp.log  $t/$p_incomplete
	fi

	if [[ -f "${t_spec[1]}" ]]; then
	    mv "${t_spec[1]}"   $t/$p_info/${t_spec[1]:t}
	    ln -r -s $t/$p_info/${t_spec[1]:t} $t/srpm.spec
	fi

	# TODO HANDLE ERRORS
	if [[ -d "$t/$p_xtmp/SOURCES" ]] && ( ! is_empty_dir "$t/$p_xtmp/SOURCES" ); then
	    make_all_readable    "$t/$p_xtmp/SOURCES"
	    mv $t/$p_xtmp/SOURCES/*      $t/$p_archives
	fi

	if [[ -d "$t/$p_xtmp/BUILD" ]] && ( ! is_empty_dir "$t/$p_xtmp/BUILD" ); then
	    make_all_readable    "$t/$p_xtmp/BUILD"
	    mv $t/$p_xtmp/BUILD/*     $t/$p_pre_build
	fi
    }

    set -e
    if [[ -f "$t/$p_log/x_srpm-rpmbuild-bp.log" ]]; then
	x_expand_srpm_clean_patch_backup_files "$t/$p_pre_build" "$t/$p_log/x_srpm-rpmbuild-bp.log" \
					       > "$t/$p_log/x_srpm-clean-patch-backupfile.log"
    fi

    make_file_unwritable "$t/$p_archives"
    make_file_unwritable "$t/$p_pre_build"

    # x_expand_srpm_owner

    set +e
    return $s
}

x_expand_srpm_clean_patch_backup_files()
{
    local target=$1
    local hint=$2

    local suffix
    local patched_file
    local backup_file
    local f
    while IFS= read -r; do
	if [[ "$REPLY" =~ '.*/patch[[:space:]]{1,}.*[[:space:]]{1,}--suffix[[:space:]]{1,}([^[:space:]]{1,}).*' ]]; then
	    suffix=${REPLY[${mbegin[1]}, ${mend[1]}]}
	elif [[ "$REPLY" =~ '^patching file (.{1,})$' ]]; then
	    patched_file=${REPLY[${mbegin[1]}, ${mend[1]}]}
	    if [[ -z "${suffix}" ]]; then
		continue
	    fi
	    backup_file=${patched_file}${suffix}

	    for f in ${target}/**/${backup_file}(N); do
		[[ -e $f ]] && rm "$f" && echo "${f#${target}/}"
	    done
	fi
    done < ${hint}
}

x_expand_srpm_check()
{
    :
}

EXPANDER[lcopy]="local copy"
REQUIREMENTS[expander_lcopy]="git"
x_expand_lcopy_help()
{
    :
}

x_expand_lcopy_run()
{
    # TODO: update
    local lcopy=$1
    local t=$2
    local s

    lcopy_checkout $lcopy $t/$p_xtmp > $t/$p_log/x_lcopy-checkout.log 2>&1
    s=$?
    echo $s > "$t/$p_log/x_lcopy-checkout.status"
    cp ${lcopy} $t/$p_info/_.lcopy
    if ! is_empty_dir "$t/$p_xtmp"; then
	mv $t/$p_xtmp/*      $t/$p_archives
    fi

    if [[ $s != 0 ]]; then
	=printf "%s (%s: %s)\n" $s_incomplete $(lcopy_describe_error $s) ${lcopy:t} \
	 > $t/.$p_status
    fi
    return $s
}

x_expand_lcopy_check()
{
    :
}
#
#
# MAIN
#
#

init()
{
    XCMD_DIR=${SRPMIX7_XCMD_DIR:-${EVAR_DEFAULT[XCMD_DIR]}}
    if [[ ! -d "${XCMD_DIR}" ]]; then
	if [[ "${XCMD_DIR}" == "${EVAR_DEFAULT[XCMD_DIR]}" ]]; then
	    #
	    # NO WARNING
	    #
	    :
	else
	    -E- "No such directory: SRPMIX7_XCMD_DIR=${XCMD_DIR}"
	fi
    elif ! XCMD_DIR=$(realpath -q "${XCMD_DIR}"); then
	-E- "Cannot resolve path: XCMD_DIR=${XCMD_DIR}"
    else
	SRPMIX7_XCMD_DIR=${XCMD_DIR}
    fi
}

help()
{
    local r=$1

    printf "Command usage:\n"
    =printf "	%-40s %s\n" "$SELF -h|--help"             "show this help message"
    =printf "	%-40s %s\n" "$SELF [OPTIONS] SUBCOMMAND" "run SUBCOMMAND"
    =printf "	%-40s %s\n" "$SELF help SUBCOMMAND"      "show help messages about SUBCOMMAND"

    echo
    printf "Options:\n"
    =printf "	%-20s %s\n" "-x|--trace"      "trace the execution"

    echo
    printf "Subcommands:\n"
    subcommand_enumerate -v | indent

    echo
    printf "Environment variables:\n"
    evar_enumerate -v | indent

    echo
    exit $r
}

run()
{
    local c
    local r

    if [[ $# -eq 0 ]]; then
	help 1 1>&2
    else
	case "$1" in
	    (-h|--help)
		help 0
		;;
	    (-x|--trace)
		set -x
		shift
		;;
	    (-*)
		-E%- "unknown option: %s\n" "$1"
		;;
	    (*)
		;;
	esac
    fi

    if ! subcommand_exist_p "$1"; then
	-E%- "unknown subcommand: %s\n" "$1"
    else
	c="$1"
	shift
    fi


    subcommand_run "$c" "$@"
    r=$?

    return $r
}

#
#
# LCOPY
#
#
readonly lcopy_cf_version=0.4
readonly lcopy_git_cf_version=0.0.1

readonly lcopy_error_wrong_syntax=1
readonly lcopy_error_undefined_value=2

typeset -a LCOPY_ERROR
LCOPY_ERROR=(
    "broken lcopy file (failed in source)"
    "expected value is not defined in lcopy file"
    "failed in checkout operation"
)

lcopy_describe_error()
{
    local msg=${LCOPY_ERROR[$1]}
    echo "lcopy: ${msg:-unknown error code: $1}"
}

lcopy_git_checkout()
{
    local input=$1
    local dir=$2
    local s

    (
	if source ${lcopy}; then
	    if [[ -z "${GIT_REPOSITORY}" ]]; then
		echo "no GIT_REPOSITORY in $input" 1>&2
		return ${lcopy_error_undefined_value}
	    fi

	    if [[ -z "${GIT_BRANCH}" ]]; then
		git clone --recursive "${GIT_REPOSITORY}" "${dir}"
	    else
		git clone --recursive --branch "${GIT_BRANCH}" "${GIT_REPOSITORY}" "${dir}"
	    fi
	    s=$?

	    if [[ $s != 0 ]]; then
		return ${lcopy_failed_in_checkout}
	    fi
	else
	    return ${lcopy_error_wrong_syntax}
	fi
    )
}

lcopy_checkout()
{
    local lcopy=$1
    local vcs

    if ! vcs=$( source "${lcopy}" && echo "$LCOPY_VCS" ); then
	return ${lcopy_error_wrong_syntax}
    elif [[ -z "${vcs}" ]]; then
	return ${lcopy_error_undefined_value}
    fi

    case "$vcs" in
	(git)
	    lcopy_${vcs}_checkout "$@"
	    ;;
	(*)
	    ;;
    esac
}

lcopy_git_genconf()
{
    local repo=$1
    shift

    local branch

    while [[ $# -gt 0 ]]; do
	case "$1" in
	    (--branch)
		branch=$2
		shift 2
		;;
	    (--*)
		-E- "lcopy: unknown option given: $@"
		;;
	    (*)
		-E- "lcopy: unexpected arugment given: $@"
		;;
	esac
    done

    cat  <<EOF
# -*- shell-script -*-
GIT_CF_VERSION="${lcopy_git_cf_version}"
GIT_REPOSITORY="$repo"
EOF
    if [[ -n "${branch}" ]]; then
	cat <<EOF
GIT_BRANCH=${branch}
EOF
    fi

    cat <<EOF
LCOPY_CF_VERSION="${lcopy_cf_version}"
LCOPY_VCS="git"
LCOPY_UPDATE="yes"
LCOPY_GENERATED_BY=$SELF
EOF
    return 0
}

lcopy_genconf()
{
    local vcs=$1
    shift

    if [[ -z "$vcs" ]]; then
	-E-
    fi

    case "$vcs" in
	(git)
	    lcopy_${vcs}_genconf "$@"
	    ;;
	(*)
	    ;;
    esac
}


#
#
# VANILLA
#
#
vanilla()
{
    local archive=$1
    local output=$2
    local s

    (cd ${output};
     case "$archive" in
	 (*.zip)
	     unzip -o "$f"
	     s=$?
	     ;;
	 (*.tar.gz|*.tgz|*.tar.Z)
	     tar zxf "$archive"
	     s=$?
	     ;;
	 (*.tar.bz2|*.tbz|*.tbz2)
	     tar jxf "$archive"
	     s=$?
	     ;;
	 (*.tar.xz|*.txz)
	     tar Jxf "$archive"
	     s=$?
	     ;;
	 (*.gz|*.Z)
	     gunzip --keep --force --stdout "$archive" > ./"${archive:h:r}"
	     s=$?
	     ;;
	 (*.bz2)
	     bunzip2 --keep --force --stdout "$archive" > ./"${archive:h:r}"
	     s=$?
	     ;;
	 (*.xz)
	     unxz --keep --force --stdout "$archive"   > ./"${archive:h:r}"
	     s=$?
	     ;;
	 (*)
	     echo "vanilla: no handler for $archive" 2>&1
	     s=1
	     ;;
     esac
     exit $s
    )
    return $?
}

#
# pname
#
pname_name()
{
    local expander=$1
    local src=$2

    # TODO check
    x_expand_${expander}_name_name $2

}

pname_version()
{
    local expander=$1
    local src=$2

    # TODO check
    x_expand_${expander}_name_version $2
}


#
# file locking
#
lock()
{
    local v=$1
    integer -l r

    exec {r}< $2
    if flock --nonblock $r; then
	eval "$v"="$r"
	return 0
    else
	return 1
    fi
}

unlock()
{
    integer -l r=$1
    exec {r}>&-
}


init
run "$@"

#
# FILE/DIRECTORY LAYOUT SPECIFICATION
# ======================================================================
#
# The 7th raw directory specification
# ----------------------------------------------------------------------
# *archives* directory
#
#	the original data and patches
#
# *pre-build* directory/symlink
#
#	synthesized data for compiler
#       A symlink is used in the case nothing is synthesized.
#
# *specs* directory
#
#       Meta information about the source code.
#       The contents are upto an expander.
#       e.g. specs.spec in srpmix5 is renamed to
#            *specs*/srpm.spec.
#
#
# *_status* file
#
#       The result of expansion/synthesizing.
#
#       The file content is one of following.
#
#	`unknown`
#
#                 The expansion is failed too early stage to record the
#                 status. It implies the issue in th environment of expansion.
#
#	`successful`
#
#                 The expansion is successfully done. Expanded/synthesized
#                 source code are reliable to source code analysis/reading.
#
#	`error(REASON)`
#
#                 The expansion is failed in a stage of expansion or
#                 synthesizing.
#                 Be careful: expanded/synthesized source code are NOT
#                 reliable to use in your job. More information about the
#                 error can be found in _log directory (if available).
#
#       If this *_status* doesn't exist, it means the expanding/synthesizing
#       is in progress. You and your tool should not touch the source code here.
#
# *_log* directory
#
#       Log files generated during expanding and synthesizing.
#
# *_bundles*
#
#       Extra files generated by hook commands/functions(postprocessor, pp).
#       Typical usage of this directory is storing search indexes for the
#       source code. That was *plugins* directory in srpmix5.
#
#       *_bundles* has its own layout:
#
#	*_bundles*/*pp name* directory
#
#		*_version* file
#
#			The version information of pp.
#
#		*_status* file
#
#                       The pp execution status.
#
# *_uname* directory
#
#	Information about srpmix7 itself.
#
#       *version* file
#
#             The version information of srpmix7.
#
# *__tmp* directory
#
#	Working area of srpmix7. You should not see these.
#
#
# *vanilla* symlink in srpmix5 is gone.
#

# The 7th upper directory specification
# ----------------------------------------------------------------------
# ...


# Interface between main and subcommand
# ----------------------------------------------------------------------
#
# There are two ways to implement a subcommand.
#
# A. xcmd - external subcommand
#
#    An executable XCMD must exist at ${SRPMIX7_XCMD_DIR}/xcmd-${XCMD}.
#
#    XCMD takes following subcommands:
#
#    A.1 help
#    A.2 desc
#    A.3 run "$@"
#
#
# B. icmd - internal subcommand
#
#    A ICMD command is implemented as zsh functions:
#
#    B.1 ${ICMD}_help
#    B.2 ${ICMD}_run
#
#
